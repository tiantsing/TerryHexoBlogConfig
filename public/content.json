{"meta":{"title":"Terry_Tian's Code日志","subtitle":"行是知之始，知是行之成。","description":"在山的这边，海的那边，有一只程序猿。。。","author":"Terry Tian","url":"http://tianqing.work"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-09-06T01:24:38.000Z","updated":"2019-09-06T01:26:16.091Z","comments":false,"path":"/404.html","permalink":"http://tianqing.work//404.html","excerpt":"","text":".article-header { padding: 0; padding-top: 26px; border-left: none; text-align: center; } .article-header:hover { border-left: none; } .article-title { font-size: 2.1em; } strong a { color: #747474; } .article-meta { display: none; } .share { display: none; } .ds-meta { display: none; } .player { margin-left: -10px; } .sign { text-align: right; font-style: italic; } #page-visit { display: none; } .center { text-align: center; height: 2.5em; font-weight: bold; } .article-entry hr { margin: 0; } .pic { text-align: center; margin: 0; } .pic br { display: none; } #container .article-info-post.article-info { display: none; } #container .article .article-title { padding: 0; }"},{"title":"关于我","date":"2017-02-17T07:17:36.000Z","updated":"2019-09-06T01:26:21.802Z","comments":false,"path":"about/index.html","permalink":"http://tianqing.work/about/index.html","excerpt":"","text":"strong a { color: #747474; } .player { text-align: center; margin: .5em auto 0; width: 100%; max-width: 22em; } .player br { display: none; } .sign { text-align: right; font-style: italic; } #ds-recent-visitors { margin: 0; padding: 0; } #ds-recent-visitors div img { display: inline-block !important; width: 56px !important; height: 56px !important; border-radius: 50%; border: 1px solid #ddd; padding: 2px; box-shadow: 1px 1px 1px rgba(0,0,0, .15); } .article-entry img:first-child { display: block; } .article-entry span { font-family: Arial; } #ds-hot-posts { display: none; } 开博缘由: 通过写博客的方式，加深理解，显性化自己的隐性知识； 共享知识，吸引同好，交流进步。 欢迎交流: QQ：1015236187 Email:tiantsing@126.com CSDN：Terry_Tian Sina:Terry_Tian Github:MuTouTQ 最近访客："},{"title":"分类","date":"2017-02-17T07:17:36.000Z","updated":"2017-03-06T12:41:07.315Z","comments":false,"path":"categories/index.html","permalink":"http://tianqing.work/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2015-09-30T12:31:36.000Z","updated":"2017-03-06T12:43:43.914Z","comments":true,"path":"guestbook/index.html","permalink":"http://tianqing.work/guestbook/index.html","excerpt":"","text":"strong a { color: #747474; } .player { text-align: center; margin: .5em auto 0; width: 100%; max-width: 22em; } .player br { display: none; } .sign { text-align: right; font-style: italic; } #ds-recent-visitors { margin: 0; padding: 0; } #ds-recent-visitors div img { display: inline-block !important; width: 56px !important; height: 56px !important; border-radius: 50%; border: 1px solid #ddd; padding: 2px; box-shadow: 1px 1px 1px rgba(0,0,0, .15); } .article-entry img:first-child { display: block; } .article-entry span { font-family: Arial; } #ds-hot-posts { display: none; } 如果大家有什么想说的，可以在这里留言！ —— Terry_Tian, 2017年2月17日 最近访客："},{"title":"标签","date":"2017-02-17T07:17:36.000Z","updated":"2017-03-06T12:41:55.553Z","comments":false,"path":"tags/index.html","permalink":"http://tianqing.work/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"photo","slug":"photo","date":"2020-08-18T14:51:45.000Z","updated":"2020-08-18T14:55:51.247Z","comments":true,"path":"2020/08/18/photo/","link":"","permalink":"http://tianqing.work/2020/08/18/photo/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"多个maven项目启动顺序","slug":"多个maven项目启动顺序","date":"2020-08-17T12:44:07.000Z","updated":"2020-08-17T15:36:36.859Z","comments":true,"path":"2020/08/17/多个maven项目启动顺序/","link":"","permalink":"http://tianqing.work/2020/08/17/多个maven项目启动顺序/","excerpt":"多个maven项目启动顺序","text":"多个maven项目启动顺序 #在之前的内容会显示在首页，之后的内容会被隐藏，当游客点击Read more才能看到。 多个maven项目启动顺序问题背景在公司实际项目中，开发的项目一般都会涉及到多个 maven 项目，比如项目2会依赖项目1。使用 Jenkins 实现自动部署时，除了写一个流水线脚本时，就需要找一个合适的 maven 命令脚本解决。 问题描述现在有两个 Maven 工程，maven1 和 maven2 ，maven2 依赖于 maven1 。maven1 的 pom 文件如下： 12345678910&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;bus-core-api&lt;/groupId&gt; &lt;artifactId&gt;bus-core-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;/project&gt; maven2 的pom文件如下： 12345678910111213141516&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;app-desktop-ui&lt;/groupId&gt; &lt;artifactId&gt;app-desktop-ui&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;bus-core-api&lt;/groupId&gt; &lt;artifactId&gt;bus-core-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 在平时我们打包的时候，是对maven1项目先执行 maven install ，然后再对maven2 项目执行 maven clean package。有没有一种方法可以实现：我直接对maven2进行打包操作，它会自动的先对maven2依赖的项目先进行install，然后再对maven2进行打包？ 解决方案方案一首先有两个 maven 项目，maven1 和 maven2 。其中 maven2 依赖于 maven1. 这时，maven1 的 pom.xml 内容如下： 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;space.tiantsing&lt;/groupId&gt; &lt;artifactId&gt;maven1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt;&lt;/project&gt; maven2 的 pom.xml 内容如下： 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;space.tiantsing&lt;/groupId&gt; &lt;artifactId&gt;maven2&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;space.tiantsing&lt;/groupId&gt; &lt;artifactId&gt;maven1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 然后，我们在 maven2 项目中新建一个 xml 文件，pomAutom.xml 内容如下： 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;space.tiantsing&lt;/groupId&gt; &lt;artifactId&gt;mavenAutom&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; // 这里的打包方式必须为 pom &lt;modules&gt; &lt;module&gt;../maven1&lt;/module&gt; &lt;module&gt;../maven2&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 这时，我们通过 cmd 进入到 maven2 项目 pom 文件所在的目录，执行命令 mvn clean package -f pomAutom.xml ,这时就会按照你在 pomAutom.xml 中 1234&lt;modules&gt; &lt;module&gt;../maven1&lt;/module&gt; &lt;module&gt;../maven2&lt;/module&gt; &lt;/modules&gt; 配置的顺序启动。 DEMO路径：MavenDependTemplate","categories":[{"name":"maven","slug":"maven","permalink":"http://tianqing.work/categories/maven/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://tianqing.work/tags/maven/"}]},{"title":"Java单例模式的5种实现方法","slug":"Java单例模式的5种实现方法","date":"2020-08-17T11:44:07.000Z","updated":"2020-08-17T15:24:57.565Z","comments":true,"path":"2020/08/17/Java单例模式的5种实现方法/","link":"","permalink":"http://tianqing.work/2020/08/17/Java单例模式的5种实现方法/","excerpt":"Java单例模式的5种实现方法 饿汉 懒汉-（线程安全） 双重校验锁 静态内部类 枚举","text":"Java单例模式的5种实现方法 饿汉 懒汉-（线程安全） 双重校验锁 静态内部类 枚举 #在之前的内容会显示在首页，之后的内容会被隐藏，当游客点击Read more才能看到。 Java单例模式的5种实现方法饿汉类加载的时候就创建了实例 优点：类加载的时候创建一次实例，避免了多线程同步问题 缺点：即使单例没被用到也会创建，浪费内存 1234567public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; 懒汉-（线程安全） 缺点：性能问题，添加了synchronized的函数比一般方法慢得多，若多次调用getInstance，则累积的性能损耗特别大。 12345678910public class Singleton &#123; private static Singleton instance = null; private Singleton() &#123; &#125; public static Synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 双重校验锁1234567891011121314public class Singleton &#123; private static volatile Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized(Singleton.class) &#123; if (instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 静态内部类12345678910public class StaticSingleton &#123; private StaticSingleton() &#123;&#125; private static class SingletonHolder &#123; private static StaticSingleton INSTANCE = new StaticSingleton(); &#125; public static getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 枚举 调用方式：Singleton.INSTANCE.getInstance() 12345678910111213class Resource&#123;&#125; public enum Singleton &#123; INSTANCE; private Resource instance; Singleton() &#123; instance = new Resource(); &#125; public Resource getInstance() &#123; return instance; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://tianqing.work/categories/设计模式/"}],"tags":[{"name":"单例模式","slug":"单例模式","permalink":"http://tianqing.work/tags/单例模式/"}]},{"title":"1.初识RabbitMQ","slug":"1.初识RabbitMQ","date":"2019-09-05T12:52:52.000Z","updated":"2019-09-06T03:14:13.694Z","comments":true,"path":"2019/09/05/1.初识RabbitMQ/","link":"","permalink":"http://tianqing.work/2019/09/05/1.初识RabbitMQ/","excerpt":"感谢阅读这篇博文，欢迎关注与评论！ 什么是消息中间件？ 消息中间件的作用 RabbitMQ 的安装及简单使用","text":"感谢阅读这篇博文，欢迎关注与评论！ 什么是消息中间件？ 消息中间件的作用 RabbitMQ 的安装及简单使用 1.什么是消息中间件？消息队列中间件 (Message Queue Middleware ，简称为 MQ) 是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。 2.消息中间件的作用 解耦:在项目启动之初来预测将来会碰到什么需求是极其困难的。消息中间件在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，这允许你独立地扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束即可。 冗余〈存储)： 有些情况下，处理数据的过程会失败。消息中间件可以把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。在把 个消息从消息中间件中删除之前，需要你的处理系统明确地指出该消息己经被处理完成，从而确保你的数据被安全地保存直到你使用完毕。 扩展性: 因为消息中间件解耦了应用的处理过程，所以提高消息入队和处理的效率是很容易的，只要另外增加处理过程即可，不需要改变代码，也不需要调节参数。 削峰: 在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流 并不常见。如果以能处理这类峰值为标准而投入资源，无疑是巨大的浪费 使用消息中间件能够使关键组件支撑突发访问压力，不会因为突发的超负荷请求而完全崩潰。 可恢复性: 当系统一部分组件失效时，不会影响到整个系统，消息中间件降低了进程间的稿合度，所以即使处理消息的进程挂掉，加入消息中间件中的消息仍然可以在系统恢复后进行处理。 顺序保证: 在大多数使用场景下，数据处理的顺序很重要，大部分消息中间件支持一定程度上的顺序性。 缓冲: 在任何重要的系统中，都会存在需要不同处理时间的元素。消息中间件通过 个缓冲层来帮助任务最高效率地执行，写入消息中间件的处理会尽可能快速，该缓冲层有助于控制和优化数据流经过系统的速度。 异步通信: 在很多时候应用不想也不需要立即处理消息 消息中间件提供了异步处理机制，允许应用把 些消息放入消息中间件中，但并不立即处理它，在之后需要的时候再慢慢处理。3.RabbitMQ 的安装及简单使用 RabbitMQ 是由 Erlang 语言编写的 也正因如此 在安装 RabbitMQ 之前需要安装 Erlang 。 1.安装Erlang(以Linux环境下为例) 新建文件夹，将 Erlang 与 RabbitMQ 安装到一起，执行如下命令 123cd /usr/local/src/ //进入此目录下mkdir rabbitmq //创建文件夹cd rabbitmq //进入新创建的文件夹 修改 rabbitmq-erlang.repo 文件中的内容：1vi /etc/yum.repos.d/rabbitmq-erlang.repo 内容如下:（可以看出是安装的21x版本的 Erlang）1234567[rabbitmq-erlang] name=rabbitmq-erlangbaseurl=https://dl.bintray.com/rabbitmq-erlang/rpm/erlang/21/el/7gpgcheck=1gpgkey=https://dl.bintray.com/rabbitmq/Keys/rabbitmq-release-signing-key.ascrepo_gpgcheck=0enabled=1 安装 Erlang 1sudo yum install erlang 验证是否安装成功，输入命令：erl。 2.安装 RabbitMQ(以Linux环境下为例) 将下载的安装包上传到上边创建的rabbitmq目录下，执行如下命令 12rpm --import https://www.rabbitmq.com/rabbitmq-signing-key-public.ascyum install rabbitmq-server-3.6.1-1.noarch.rpm//选择自己的包进行安装 常用的 rabbitMQ 命令 12345启动：systemctl start rabbitmq-server停止：service rabbitmq-server stop重启：service rabbitmq-server restart开机自动启动：systemctl enable rabbitmq-server查看 rabbitmq-server 状态：rabbitmqctl status 设置配置文件 123cd /etc/rabbitmqcp /usr/share/doc/rabbitmq-server-3.4.1/rabbitmq.config.example /etc/rabbitmq/mv rabbitmq.config.example rabbitmq.config 开启用户远程访问 1vi /etc/rabbitmq/rabbitmq.config 123%% Uncomment the following line if you want to allow access to the %% guest user from anywhere on the network. %% &#123;loopback_users, []&#125; //注意要去掉后面的逗号。 开启web界面管理工具12rabbitmq-plugins enable rabbitmq_managementservice rabbitmq-server restart 可以在本机浏览器输入 http://localhost:15672 访问 rabbitmq 主页，账户 guest 密码 guest。 防火墙开放15672端口1/sbin/iptables -I INPUT -p tcp --dport 15672 -j ACCEPT 注：关闭虚拟机centos的防火墙12345678910111213141516一、.对于centos7自带的防火墙的相关指令 systemctl stop firewalld.service #停止firewall systemctl disable firewalld.service #禁止firewall开机启动 systemctl status firewalld.service #查看firewall的状态二、iptables防火墙的相关状态 关闭虚拟机防火墙： 关闭命令： service iptables stop 永久关闭防火墙：chkconfig iptables off 两个命令同时运行，运行完成后查看防火墙关闭状态 service iptables status 1 关闭防火墙: service iptables stop 2 启动防火墙: service iptables start 3 重启防火墙: service iptables restart 4 查看防火墙状态: service iptables status 5 永久关闭防火墙: chkconfig iptables off 6 永久关闭后启用: chkconfig iptables on 简单配置 RabbitMQ 添加自定义用户名为 “admin” 以及密码为 “123456” 的管理员账号： 执行命令 rabbitmqctl add_user admin 123456。 给 admin 账号设置为管理员：执行命令 rabbitmqctl set_user_tags admin administrator。 给 admin 账号授权：执行命令 rabbitmqctl set_permissions -p / admin “.“ “.“ “.*”。 查看 admin 账户的权限： 执行命令 rabbitmqctl list_user_permissions admin。 日志文件以及配置文件的位置 日志文件在：$RABBITMQ_LOG_BASE/$RABBITMQ_NODENAME.log下面，一般 $RABBITMQ_LOG_BASE=$RABBITMQ_HOME/var/log/rabbitmq。一般默认日志文件会在/var/log/rabbitmq文件下. 该日志文件的开始部分记录了rabbitmq 启动时查找相关文件的记录，例如：1234567node : rabbit@macvmhome dir : /var/lib/rabbitmqconfig file(s) : (none)cookie hash : jzIB5AXnFFYHzF/o4qC9sw==log(s) : /var/log/rabbitmq/rabbit@macvm.log : /var/log/rabbitmq/rabbit@macvm_upgrade.logdatabase dir : /var/lib/rabbitmq/mnesia/rabbit@macvm 日志记录显示了各个系统文件对应的位置。","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://tianqing.work/categories/RabbitMQ/"}],"tags":[{"name":"消息中间件","slug":"消息中间件","permalink":"http://tianqing.work/tags/消息中间件/"}]},{"title":"软件分享篇（Windows10）","slug":"软件分享篇","date":"2019-05-18T12:27:07.944Z","updated":"2017-03-02T15:28:16.622Z","comments":true,"path":"2019/05/18/软件分享篇/","link":"","permalink":"http://tianqing.work/2019/05/18/软件分享篇/","excerpt":"今晚有点晚了，就不撸代码了，决定把我电脑里常用的软件、工具分享给大家，这些软件真的很好用，不信你可以试一试！ 转载请注明：转载于Terry Tian的博客（www.mutouspace.cn）!","text":"今晚有点晚了，就不撸代码了，决定把我电脑里常用的软件、工具分享给大家，这些软件真的很好用，不信你可以试一试！ 转载请注明：转载于Terry Tian的博客（www.mutouspace.cn）! 安全杀毒： TT电脑里用的杀毒防护软件是Windows系统自带的Windows Defender，说实话，现在Windows自带的杀软已经很好了，具体好到哪，大家可以自行百度、google。软件界面简单、实用，还没有广告，界面如下： 清理软件我用的是口碑很好的 CCleaner,功能完全足够你使用了！截图如下： 对于非一般的用户，特别是计算机专业的学生，真的不是很建议在电脑了安装些安全卫士、管家、毒霸等软件的！ 开发工具 Android Studio：对于这款软件大家一定都不陌生，特别是对于一位安卓开发人员，Google的亲儿子，好好享受吧！ eclipse：一款插件丰富的开发工具，java开发者用的挺多，以前也用于开发安卓，可惜Google生了个儿子。 SQLite Expert Personal：一款可以查看数据表中数据的软件，安卓开发人员都值得拥有！ 系统工具 chrome：好用的不能再好用的浏览器。插件丰富，但需要科学上网。 缺点就是在国内没法云备份自己的收藏夹。推荐大家可以在安装一款360极速浏览器、或者QQ浏览器来备份自己的收藏夹。 MarkdownPad 2：我认为这可能是Windows系统下最好用的markdown书写软件了，可以去官网下载。 Seer:是一款 Windows 下的文件预览工具，可以无需打开图片、音乐、视频、压缩包等文件就能预览到内容，只需点一下空格。下载地址：http://www.appinn.com/seer-windows/。 护眼宝：是一款护眼的工具，下载地址：http://www.huyanbao.com/#top。 Clover:Clover 是 Windows Explorer 资源管理器的一个扩展，为其增加类似谷歌 Chrome 浏览器的多标签页功能。 ADSafe：ADSafe是一款好用的广告屏蔽软件！ HoneyView:HoneyView是一个支持多种格式的极速图像浏览器。 她同时支持不解压浏览ZIP、RAR和7z压缩包中的图片。 她可以显示图片的GPS信息并在Google Maps中查看该地点，同时用户可以储存喜爱的照片。 影音工具 网易云音乐（UWP）：逼格漫漫的音乐播放器。 Potplayer：PotPlayer诚意满满的视频播放器。 下载工具 IDM：Internet Download Manager(简称“IDM”)是国外的一款下载工具，提升你的下载速度最多达5倍，安排下载时程，或续传一半的软件。Internet Download Manager的续传功能可以恢复因为断线、网络问题、计算机当机甚至无预警的停电导致下传到一半的软件。 EagleGet:EagleGet（亦称 EG Download Accelerator）是一个用于 Windows 系统的下载管理器，它是免费软件。EagleGet 使用多线程技术，支持从Youtube、Dailymotion、Facebook、Vimeo等视频网站下载 MP4 和 FLV 格式视频。EagleGet 是一个拥有简洁界面和功能的免费的新下载管理器。 迅雷：国内用户电脑中常备的下载软件，大多数网站也都支持迅雷下载。但我真的越来越讨厌迅雷了，不仅下载速度限速，界面也越来越复杂，广告还多，越来越丧失了一款下载软件的本心。 分享到这里就结束了，如果大家有什么疑问可以留言，有好的软件推荐给我，也可以留言，谢谢阅读！","categories":[{"name":"分享","slug":"分享","permalink":"http://tianqing.work/categories/分享/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://tianqing.work/tags/分享/"}]},{"title":"Git常用命令汇总","slug":"Git常用命令汇总","date":"2018-04-07T12:59:24.000Z","updated":"2018-04-07T13:15:46.430Z","comments":true,"path":"2018/04/07/Git常用命令汇总/","link":"","permalink":"http://tianqing.work/2018/04/07/Git常用命令汇总/","excerpt":"前言本文主要记录工作学习中用到的Git常用操作。 教程思路： 2018/4/7 星期六 下午 9:06:06 1. git中常用命令；","text":"前言本文主要记录工作学习中用到的Git常用操作。 教程思路： 2018/4/7 星期六 下午 9:06:06 1. git中常用命令； git init ：初始化 git 仓库。 git status ：查看你当前 git 仓库的一些状态。 git add ：先把改动添加到一个「暂存区」，你可以理解成是一个缓存区域，临时保存你的改动。 git commit ：是最后真正的提交，例：commit 是提交的意思，-m 代表是提交信息，相当于备注。 12git commit -m &apos;first commit&apos;git commit -a -m &apos;added new benchmarks&apos; #省略添加到缓存区的操作 git log ： 查看所有产生的 commit 记录。 git branch ：查看下当前分支情况；git branch a 新建分支a；git checkout a 切换到分支a；git checkout -b a新建一个a分支，并且自动切换到a分支。 git merge ：合并分支；合并分支的步骤：第一步是切换到 master 分支，如果你已经在了就不用切换了，第二步执行 git merge a ，意思就是把a分支的代码合并过来； git branch -d：删除分支；git branch -d a 就可以把a分支删除了。 git branch -D ：强制删除分支。 git tag：查看历史 tag 记录； git pull origin master：意思就是把远程最新的代码更新到本地。 git push origin master：意思就是把本地代码推到远程 master 分支。 git clone：把项目 clone 到了本地。 提交代码之前先要设置下自己的用户名与邮箱，这些信息会出现在所有的 commit 记录里，执行以下代码就可以设置： 12git config —global user.name &quot;TerryTian&quot;git config —global user.email &quot;tianqing12989@gmail.com&quot; git lg：先配置： 1git config --global alias.lg &quot;log --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit --date=relative&quot; 开启给 Git 着色：git config –global color.ui true 设置显示中文文件名： git config –global core.quotepath false checkout：git checkout develop：切换到 develop 分支；git checkout v1.0：切换tag.","categories":[{"name":"Git","slug":"Git","permalink":"http://tianqing.work/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://tianqing.work/tags/Git/"}]},{"title":"eclipse常用快捷键整理","slug":"eclipse常用快捷键整理","date":"2017-08-20T07:46:26.000Z","updated":"2017-09-29T00:49:09.498Z","comments":true,"path":"2017/08/20/eclipse常用快捷键整理/","link":"","permalink":"http://tianqing.work/2017/08/20/eclipse常用快捷键整理/","excerpt":"对从网上搜到的eclipse快捷键做出整理，以方便自己的使用。","text":"对从网上搜到的eclipse快捷键做出整理，以方便自己的使用。 查看和定位快捷键 在程序中，迅速定位代码的位置，快速找到 Bug 的所在，是非常不容易的事，Eclipse 提供 了强大的查找功能，可以利用如下的快捷键帮助完成查找定位的工作。 【Ctrl+K】、【Ctrl++Shift+K】快速向下和向上查找选定的内容，从此不再需要用鼠标单击查找对话框了。 【Ctrl+Shift+T】查找工作空间（Workspace）构建路径中的可找到 Java 类文件，不要为找不到类而痛苦，而且可以使用“*”、“？”等通配符。 【Ctrl+Shift+R】和【Ctrl+Shift+T】对应，查找工作空间（Workspace）中的所有文件（包括 Java 文件），也可以使用通配符。 【Ctrl+Shift+G】查找类、方法和属性的引用。这是一个非常实用的快捷键，例如要修改引用某个方法的代码，可以通过【Ctrl+Shift+G】快捷键迅速定位所有引用此方法的位置。 【Ctrl+Shift+O】快速生成 import，当从网上拷贝一段程序后，不知道如何 import 进所调用的类，试试【Ctrl+Shift+O】快捷键，一定会有惊喜。 【Ctrl+Shift+F】格式化代码，书写格式规范的代码是每一个程序员的必修之课，当看见某段代码极不顺眼时，选定后按【Ctrl+Shift+F】快捷键可以格式化这段代码，如果不选定代码则默认格式化当前文件（Java 文件）。 【ALT+Shift+W】查找当前文件所在项目中的路径，可以快速定位浏览器视图的位置，如果想查找某个文件所在的包时，此快捷键非常有用（特别在比较大的项目中）。 【Ctrl+L】定位到当前编辑器的某一行，对非 Java 文件也有效。 【Alt+←】、【Alt+→】后退历史记录和前进历史记录，在跟踪代码时非常有用，用户可能查找了几个有关联的地方，但可能记不清楚了，可以通过这两个快捷键定位查找的顺序。 【F3】快速定位光标位置的某个类、方法和属性。 【F4】显示类的继承关系，并打开类继承视图。 调试快捷键 Eclipse 中有如下一些和运行调试相关的快捷键。 【Ctrl+Shift+B】：在当前行设置断点或取消设置的断点。 【F11】：调试最后一次执行的程序。 【Ctrl+F11】：运行最后一次执行的程序。 【F5】：跟踪到方法中，当程序执行到某方法时，可以按【F5】键跟踪到方法中。 【F6】：单步执行程序。 【F7】：执行完方法，返回到调用此方法的后一条语句。 【F8】：继续执行，到下一个断点或程序结束。 常用编辑器快捷键 通常文本编辑器都提供了一些和编辑相关的快捷键，在 Eclipse 中也可以通过这些快捷键进行文本编辑。 【Ctrl+C】：复制。 【Ctrl+X】：剪切。 【Ctrl+V】：粘贴。 【Ctrl+S】：保存文件。 【Ctrl+Z】：撤销。 【Ctrl+Y】：重复。 【Ctrl+F】：查找。 其他快捷键 Eclipse 中还有很多快捷键，无法一一列举，用户可以通过帮助文档找到它们的使用方式，另外还有几个常用的快捷键如下。 【Ctrl+F6】：切换到下一个编辑器。 【Ctrl+Shift+F6】：切换到上一个编辑器。 【Ctrl+F7】：切换到下一个视图。 【Ctrl+Shift+F7】：切换到上一个视图。 【Ctrl+F8】：切换到下一个透视图。 【Ctrl+Shift+F8】：切换到上一个透视图。 Ctrl 系列Ctrl+K: 将光标停留在变量上，按 Ctrl+K 键可以查找到下一个同样的变量Ctrl+Shift+K: 和 Ctrl+K 查找的方向相反Ctrl+E: 快速显示当前 Editer 的下拉列表(如果当前页面没有显示的用黑体表示)Ctrl+Shift+E: 显示管理当前打开的所有的 View 的管理器(可以选择关闭,激活等操作)Ctrl+Q: 定位到最后编辑的地方Ctrl+L: 定位在某行 (对于程序超过 100 的人就有福音了)Ctrl+M: 最大化当前的 Edit 或 View (再按则反之)Ctrl+/: 注释当前行,再按则取消注释Ctrl+T: 快速显示当前类的继承结构Ctrl+Shift-T: 打开类型（Open type）。如果你不是有意磨洋工，还是忘记通过源码树（sourcetree）打开的方式吧。Ctrl+O: 在代码中打开类似大纲视图的小窗口Ctrl+鼠标停留: 可以显示类和方法的源码Ctrl+H: 打开搜索窗口Ctrl+/(小键盘): 折叠当前类中的所有代码Ctrl+×(小键盘): 展开当前类中的所有代码 Ctrl+Shift 系列Ctrl+Shift+F: 格式化当前代码Ctrl+Shift+X: 把当前选中的文本全部变味小写Ctrl+Shift+Y: 把当前选中的文本全部变为小写Ctrl+Shift+O: 快速地导入 importCtrl+Shift+R: 打开资源 open Resource F 快捷键 系列F3: 打开声明该引用的文件F4: 打开类型层次结构F5: 单步跳入F6: 单步跳过F7: 单步跳出F8: 继续，如果后面没有断点，程序将运行完 行编辑用Ctrl+D: 删除当前行Ctrl+Alt+↓ 复制当前行到下一行(复制增加)Ctrl+Alt+↑ 复制当前行到上一行(复制增加)Alt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了)Alt+↑ 当前行和上面一行交互位置(同上)Shift+Enter 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置,不一定是最后)Ctrl+Shift+Enter 在当前行插入空行(原理同上条) 不常用的Alt+← 前一个编辑的页面Alt+→ 下一个编辑的页面(当然是针对上面那条来说了)Ctrl+Shift+S: 保存全部Ctrl+W: 关闭当前 EditerCtrl+Shift+F4: 关闭所有打开的 EditerCtrl+Shift+G: 在 workspace 中搜索引用Ctrl+Shift+P: 定位到对于的匹配符(譬如{}) (从前面定位后面时,光标要在匹配符里面,后面到 前面,则反之) 增量查找Ctrl+J: 正向增量查找(按下 Ctrl+J 后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有,则在 stutes line 中显示没有找到了,查一个单词时,特别实用,这个功能 Idea 两年前就有了)Ctrl+Shift+J: 反向增量查找(和上条相同,只不过是从后往前查)","categories":[{"name":"工具","slug":"工具","permalink":"http://tianqing.work/categories/工具/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://tianqing.work/tags/JAVA/"},{"name":"eclipse","slug":"eclipse","permalink":"http://tianqing.work/tags/eclipse/"}]},{"title":"使用Oracle SQL Developer连接mysql数据库","slug":"使用Oracle SQL Developer连接mysql数据库","date":"2017-08-09T14:12:56.000Z","updated":"2017-08-10T00:21:01.655Z","comments":true,"path":"2017/08/09/使用Oracle SQL Developer连接mysql数据库/","link":"","permalink":"http://tianqing.work/2017/08/09/使用Oracle SQL Developer连接mysql数据库/","excerpt":"Oracle SQL Developer是Oracle官方提供的数据库连接工具。不仅可以连接自己的数据库（Oracle），而且还可以连接多种其他的数据库。MySql已经成为了Oracle旗下的产品，连接它当然也不在话下。在这里，笔者在实际开发中只进行了MySQL的连接实践，其它的数据库请读者自行研究，但应该也都是可以的。 转载请注明：转载于Terry Tian的博客（www.mutouspace.cn）!","text":"Oracle SQL Developer是Oracle官方提供的数据库连接工具。不仅可以连接自己的数据库（Oracle），而且还可以连接多种其他的数据库。MySql已经成为了Oracle旗下的产品，连接它当然也不在话下。在这里，笔者在实际开发中只进行了MySQL的连接实践，其它的数据库请读者自行研究，但应该也都是可以的。 转载请注明：转载于Terry Tian的博客（www.mutouspace.cn）! 总而言之，兼容其它的数据库方法都是比较统一的，主要就是把第三方驱动的jar包加载进来。作者环境：Windows 10 X64 MySQL的连接配置 下载第三方数据库jar包，并放到规定目录下 在SqlDeveloper中进行配置 重启工具 第一步：下载第三方数据库jar包，并放到规定目录下 第三方jar包，网上一搜一大把，我这里用的是mysql-connector-java-5.0.8-bin.jar,官方下载地址：https://www.mysql.com/products/connector/。 将jar包放入OracleSqlDeveloper的安装目录下的”jlib”目录，比如我的是：D:\\sqldeveloper-17.2.0.188.1159-no-jre\\sqldeveloper\\jlib 第二步：启动OracleSqlDeveloper，选择”工具”-“首选项”-“数据库”-“第三方jdbc驱动程序”。 选择【添加条目】，找到刚刚添加的jar包，添加后确定。 第三步：重新启动Oracle之后，创建数据库链接的地方就可以看到MySql的选项：","categories":[{"name":"数据库","slug":"数据库","permalink":"http://tianqing.work/categories/数据库/"}],"tags":[{"name":"SQL Developer","slug":"SQL-Developer","permalink":"http://tianqing.work/tags/SQL-Developer/"}]},{"title":"常用\"工具\"配置","slug":"常用工具的环境变量配置","date":"2017-07-30T06:44:56.000Z","updated":"2018-07-01T13:41:32.304Z","comments":true,"path":"2017/07/30/常用工具的环境变量配置/","link":"","permalink":"http://tianqing.work/2017/07/30/常用工具的环境变量配置/","excerpt":"（2017-03-24）本博文主要介绍一些工具安装后对环境变量的配置，本来不打算写这种博文的，这种博文在网上一搜一大把，但网络资源鱼龙混杂，有的教程可能并不适合自己的环境，所以就写了这样一篇环境配置的博文，既然写了，那以后再遇到环境配置的问题还会继续添加，如有错误，欢迎大家指出，谢谢！ （2017-07-30）为了自己记录的方便，本文章不在单独的只对类如JDK、Tomact这样的工具做环境变量配置的记录，同时增加对开发学习中遇到的一些方法库的使用如何配置使用做记录。 转载请注明：转载于Terry Tian的博客（www.mutouspace.cn）! date: 2017-03-24 17:34:56 JDK的环境变量配置 Tomcat的环境变量配置 JSP 标准标签库（JSTL） Maven安装配置","text":"（2017-03-24）本博文主要介绍一些工具安装后对环境变量的配置，本来不打算写这种博文的，这种博文在网上一搜一大把，但网络资源鱼龙混杂，有的教程可能并不适合自己的环境，所以就写了这样一篇环境配置的博文，既然写了，那以后再遇到环境配置的问题还会继续添加，如有错误，欢迎大家指出，谢谢！ （2017-07-30）为了自己记录的方便，本文章不在单独的只对类如JDK、Tomact这样的工具做环境变量配置的记录，同时增加对开发学习中遇到的一些方法库的使用如何配置使用做记录。 转载请注明：转载于Terry Tian的博客（www.mutouspace.cn）! date: 2017-03-24 17:34:56 JDK的环境变量配置 Tomcat的环境变量配置 JSP 标准标签库（JSTL） Maven安装配置 大家既然想找的是如何配置环境变量，那读者一定知道软件是如何下载、如何安装的，所以本文中就不再过多的介绍下载和安装过程了，重点记录一下环境变量的配置。作者环境：Windows 10 X64 JDK的环境变量配置 新建JAVA_HOME 新建CLASSPATH 编辑PATH 第一步：“我的电脑” -&gt; 右击 -&gt; “属性” -&gt; “高级系统设置” -&gt; “环境变量”; 第二步：新建JAVA_HOME 里边填入jdk的绝对地址： E:\\JAVA\\jdk 注意：最后不要加分号！！！！ 第三步：新建CLASSPATH 内容为： .;%JAVA_HOME%\\lib; 注意：不要忘记前面的“ .; ”！！！！ 第四步：编辑PATH 新加入： %JAVA_HOME%\\bin; 注意：每个路径之间都有分号！！！！ 第五步：在控制台页面分别输入 “java” “javac” “java -version” 做测试 Tomcat的环境变量配置 新建变量名：CATALINA_BASE，变量值：E:\\tomcat 新建变量名：CATALINA_HOME，变量值：E:\\tomcat 打开PATH，添加变量值：%CATALINA_HOME%\\lib;%CATALINA_HOME%\\bin; 有了JDK环境变量配置的经验，我相信大家对配置都已经轻车熟路了，这里就不配图了。 最后一步： 在CMD命令下输入命令：startup，出现如下对话框，表明服务启动成功。 JSP 标准标签库（JSTL）JSP标准标签库（JSTL）是一个JSP标签集合，它封装了JSP应用的通用核心功能。具体详细介绍请各位读者自行Google或者百度，这里不做赘述。 JSTL 库安装 安装步骤如下： 从Apache的标准标签库中下载的二进包(jakarta-taglibs-standard-current.zip)。 官方下载地址：http://archive.apache.org/dist/jakarta/taglibs/standard/binaries/ 下载jakarta-taglibs-standard-1.1.2.zip 包并解压，将jakarta-taglibs-standard-1.1.2/lib/下的两个jar文件：standard.jar和jstl.jar文件拷贝到/WEB-INF/lib/下。 接下来我们在 web.xml 文件中添加以下配置： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app version=&quot;2.4&quot; xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;&gt; &lt;jsp-config&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jstl/fmt&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/fmt.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jstl/fmt-rt&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/fmt-rt.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jstl/core&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/c.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jstl/core-rt&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/c-rt.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jstl/sql&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/sql.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jstl/sql-rt&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/sql-rt.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jstl/x&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/x.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jstl/x-rt&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/x-rt.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;/jsp-config&gt; &lt;/web-app&gt; 接下来就是在JSP文件中具体的使用了，使用方法不做赘述。 Maven安装配置 Maven是基于项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。Maven是跨平台的项目管理工具。主要服务于基于Java平台的项目构建，依赖管理和项目信息管理。 Maven主要有两个功能： 1、项目构建 2、依赖管理 安装配置步骤如下： 下载maven 官方网站：http://maven.apache.org 具体应该使用那个版本做开发：1.公司中以公司要求选择；2个人开发、学习时依据个人的喜好选择。 Maven是使用java开发，需要安装jdk1.6以上，推荐使用1.7 Maven的安装 第一步：安装jdk，要求1.6或以上版本。如何安装JDK与配置环境变量请参考本文中的JDK环境变量配置一节。 第二步：把maven解压缩，解压目录最好不要有中文。 第三步：配置环境变量MAVEN_HOME 第四步：配置环境变量PATH，将%MAVEN_HOME%\\bin加入Path中，在Windows中一定要注意要用分号；与其他值隔开。 第五步：验证是否安装成功，打开cmd窗口，输入mvn –v Maven的配置 Maven有两个settings.xml配置文件，一个是全局配置文件，一个是用户配置文件。 一、全局配置（默认）%MAVEN_HOME%/conf/settings.xml 是maven全局的配置文件。该配置文件中配置了本地仓库的路径，默认就是：~/.m2/repository。其中~表示当前用户路径C:\\Users[UserName]。 二、用户配置 ~/.m2/settings.xml是用户的配置文件（默认没有该文件，需要将全局配置文件拷贝过来在进行修改） 注意：一般本地仓库的地址不使用默认配置，通常情况下需要在用户配置中，配置新的仓库地址。 配置步骤如下： 第一步：创建一个本地仓库目录，比如G:\\TMavenPro\\repository。 第二步：复制maven的全局配置文件到~/.m2目录下，即创建用户配置文件 第三步：修改maven的用户配置文件。 注意：用户级别的仓库在全局配置中一旦设置，全局配置将不再生效，转用用户所设置的仓库，否则使用全局配置文件中的默认路径仓库。 Maven在eclipse中的使用 第一步：查看eclipse中是否有maven插件,没有的话可以谷歌一下如何下载安装； 第二步：设置maven安装目录 第三步：设置用户配置","categories":[{"name":"工具","slug":"工具","permalink":"http://tianqing.work/categories/工具/"}],"tags":[{"name":"工具配置","slug":"工具配置","permalink":"http://tianqing.work/tags/工具配置/"}]},{"title":"Android中布局保存成图片","slug":"Android中布局保存成图片","date":"2017-05-12T09:38:29.000Z","updated":"2017-05-12T09:53:15.705Z","comments":true,"path":"2017/05/12/Android中布局保存成图片/","link":"","permalink":"http://tianqing.work/2017/05/12/Android中布局保存成图片/","excerpt":"概述今天做的APP中的一个表单页面需要以后蓝牙连接打印设备后打印出来，当时想过要截屏，但想了一下截屏的话太麻烦，截屏的话是将手机的屏幕截取下来，包含很多无用的信息，所以这个想法就给pass掉了；后来又想到了转化为图片、PDF什么的，在网上搜索了一些相关信息后，发现还是将整个布局变成图片比较简单，并且也找到了一篇不错测教程，文末附有链接。","text":"概述今天做的APP中的一个表单页面需要以后蓝牙连接打印设备后打印出来，当时想过要截屏，但想了一下截屏的话太麻烦，截屏的话是将手机的屏幕截取下来，包含很多无用的信息，所以这个想法就给pass掉了；后来又想到了转化为图片、PDF什么的，在网上搜索了一些相关信息后，发现还是将整个布局变成图片比较简单，并且也找到了一篇不错测教程，文末附有链接。 实现流程以及实现代码设置权限&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt; 获取布局relativeLayout = (RelativeLayout) findViewById(R.id.layout_rl); 设置布局相关设置 // 获取图片某布局 relativeLayout.setDrawingCacheEnabled(true); relativeLayout.buildDrawingCache(); 获取图片final Bitmap bmp = relativeLayout.getDrawingCache(); // 获取图片 savePicture(bmp, &quot;test.jpg&quot;);// 保存图片 保存图片public void savePicture(Bitmap bm, String fileName) { Log.i(&quot;xing&quot;, &quot;savePicture: ------------------------&quot;); if (null == bm) { Log.i(&quot;xing&quot;, &quot;savePicture: ------------------图片为空------&quot;); return; } File foder = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + &quot;/test&quot;); if (!foder.exists()) { foder.mkdirs(); } File myCaptureFile = new File(foder, fileName); try { if (!myCaptureFile.exists()) { myCaptureFile.createNewFile(); } BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(myCaptureFile)); //压缩保存到本地 bm.compress(Bitmap.CompressFormat.JPEG, 90, bos); bos.flush(); bos.close(); } catch (IOException e) { e.printStackTrace(); } Toast.makeText(this, &quot;保存成功!&quot;, Toast.LENGTH_SHORT).show(); } 释放资源relativeLayout.destroyDrawingCache(); 完整代码如下package com.adwan.savephototolocal; import android.graphics.Bitmap; import android.os.Environment; import android.os.Handler; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.RelativeLayout; import android.widget.Toast; import java.io.BufferedOutputStream; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; public class MainActivity extends AppCompatActivity { private RelativeLayout relativeLayout; private Handler mHandler = new Handler(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); relativeLayout = (RelativeLayout) findViewById(R.id.layout_rl); } public void save(View view) { initView(); } private void initView() { // 获取图片某布局 relativeLayout.setDrawingCacheEnabled(true); relativeLayout.buildDrawingCache(); mHandler.postDelayed(new Runnable() { @Override public void run() { // 要在运行在子线程中 final Bitmap bmp = relativeLayout.getDrawingCache(); // 获取图片 savePicture(bmp, &quot;test.jpg&quot;);// 保存图片 relativeLayout.destroyDrawingCache(); // 保存过后释放资源 } },100); } public void savePicture(Bitmap bm, String fileName) { Log.i(&quot;xing&quot;, &quot;savePicture: ------------------------&quot;); if (null == bm) { Log.i(&quot;xing&quot;, &quot;savePicture: ------------------图片为空------&quot;); return; } File foder = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + &quot;/test&quot;); if (!foder.exists()) { foder.mkdirs(); } File myCaptureFile = new File(foder, fileName); try { if (!myCaptureFile.exists()) { myCaptureFile.createNewFile(); } BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(myCaptureFile)); //压缩保存到本地 bm.compress(Bitmap.CompressFormat.JPEG, 90, bos); bos.flush(); bos.close(); } catch (IOException e) { e.printStackTrace(); } Toast.makeText(this, &quot;保存成功!&quot;, Toast.LENGTH_SHORT).show(); } } 参考： http://www.jianshu.com/p/72242e612ecb#","categories":[{"name":"Android","slug":"Android","permalink":"http://tianqing.work/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://tianqing.work/tags/Android/"}]},{"title":"RecyclerView的万能分割线","slug":"RecyclerView的万能分割线","date":"2017-05-09T13:27:55.000Z","updated":"2017-07-30T06:41:22.444Z","comments":true,"path":"2017/05/09/RecyclerView的万能分割线/","link":"","permalink":"http://tianqing.work/2017/05/09/RecyclerView的万能分割线/","excerpt":"使用方法步骤： 添加默认分割线：高度为2px，颜色为灰色 添加自定义分割线：可自定义分割线drawable 添加自定义分割线：可自定义分割线高度和颜色 万能分割线登场","text":"使用方法步骤： 添加默认分割线：高度为2px，颜色为灰色 添加自定义分割线：可自定义分割线drawable 添加自定义分割线：可自定义分割线高度和颜色 万能分割线登场 使用方法：添加默认分割线：高度为2px，颜色为灰色mRecyclerView.addItemDecoration(new RecycleViewDivider(mContext, LinearLayoutManager.VERTICAL)); 添加自定义分割线：可自定义分割线drawablemRecyclerView.addItemDecoration(new RecycleViewDivider( mContext, LinearLayoutManager.VERTICAL, R.drawable.divider_mileage)); 添加自定义分割线：可自定义分割线高度和颜色mRecyclerView.addItemDecoration(new RecycleViewDivider( mContext, LinearLayoutManager.VERTICAL, 10, getResources().getColor(R.color.divide_gray_color))); 万能分割线登场：public class RecycleViewDivider extends RecyclerView.ItemDecoration { private Paint mPaint; private Drawable mDivider; private int mDividerHeight = 2;//分割线高度，默认为1px private int mOrientation;//列表的方向：LinearLayoutManager.VERTICAL或LinearLayoutManager.HORIZONTAL private static final int[] ATTRS = new int[]{android.R.attr.listDivider}; /** * 默认分割线：高度为2px，颜色为灰色 * * @param context * @param orientation 列表方向 */ public RecycleViewDivider(Context context, int orientation) { if (orientation != LinearLayoutManager.VERTICAL &amp;&amp; orientation != LinearLayoutManager.HORIZONTAL) { throw new IllegalArgumentException(&quot;请输入正确的参数！&quot;); } mOrientation = orientation; final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); a.recycle(); } /** * 自定义分割线 * * @param context * @param orientation 列表方向 * @param drawableId 分割线图片 */ public RecycleViewDivider(Context context, int orientation, int drawableId) { this(context, orientation); mDivider = ContextCompat.getDrawable(context, drawableId); mDividerHeight = mDivider.getIntrinsicHeight(); } /** * 自定义分割线 * * @param context * @param orientation 列表方向 * @param dividerHeight 分割线高度 * @param dividerColor 分割线颜色 */ public RecycleViewDivider(Context context, int orientation, int dividerHeight, int dividerColor) { this(context, orientation); mDividerHeight = dividerHeight; mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(dividerColor); mPaint.setStyle(Paint.Style.FILL); } //获取分割线尺寸 @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) { super.getItemOffsets(outRect, view, parent, state); outRect.set(0, 0, 0, mDividerHeight); } //绘制分割线 @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) { super.onDraw(c, parent, state); if (mOrientation == LinearLayoutManager.VERTICAL) { drawVertical(c, parent); } else { drawHorizontal(c, parent); } } //绘制横向 item 分割线 private void drawHorizontal(Canvas canvas, RecyclerView parent) { final int left = parent.getPaddingLeft(); final int right = parent.getMeasuredWidth() - parent.getPaddingRight(); final int childSize = parent.getChildCount(); for (int i = 0; i &lt; childSize; i++) { final View child = parent.getChildAt(i); RecyclerView.LayoutParams layoutParams = (RecyclerView.LayoutParams) child.getLayoutParams(); final int top = child.getBottom() + layoutParams.bottomMargin; final int bottom = top + mDividerHeight; if (mDivider != null) { mDivider.setBounds(left, top, right, bottom); mDivider.draw(canvas); } if (mPaint != null) { canvas.drawRect(left, top, right, bottom, mPaint); } } } //绘制纵向 item 分割线 private void drawVertical(Canvas canvas, RecyclerView parent) { final int top = parent.getPaddingTop(); final int bottom = parent.getMeasuredHeight() - parent.getPaddingBottom(); final int childSize = parent.getChildCount(); for (int i = 0; i &lt; childSize; i++) { final View child = parent.getChildAt(i); RecyclerView.LayoutParams layoutParams = (RecyclerView.LayoutParams) child.getLayoutParams(); final int left = child.getRight() + layoutParams.rightMargin; final int right = left + mDividerHeight; if (mDivider != null) { mDivider.setBounds(left, top, right, bottom); mDivider.draw(canvas); } if (mPaint != null) { canvas.drawRect(left, top, right, bottom, mPaint); } } } } 附：自定的drawable文件一份&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;size android:height=&quot;20dp&quot; /&gt; &lt;solid android:color=&quot;#ff992900&quot; /&gt; &lt;/shape&gt; 参考： RecyclerView的万能分割线","categories":[{"name":"Android","slug":"Android","permalink":"http://tianqing.work/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://tianqing.work/tags/Android/"},{"name":"Recycle","slug":"Recycle","permalink":"http://tianqing.work/tags/Recycle/"}]},{"title":"Volley 请求返回数据中文出现乱码","slug":"Volley-请求返回数据中文出现乱码","date":"2017-05-09T13:08:08.000Z","updated":"2017-05-09T13:26:40.636Z","comments":true,"path":"2017/05/09/Volley-请求返回数据中文出现乱码/","link":"","permalink":"http://tianqing.work/2017/05/09/Volley-请求返回数据中文出现乱码/","excerpt":"最近遇到一个问题。具体内容是使用Volley联网请求一段json数据，用Postman工具获取返回数据也是正确的，在别人的电脑上也是正常的，返回数据header中编码格式也是utf-8.那么问题就出在volly这个工具类上了。 经过排查，发现问题确实出在volley的一个工具类上 。","text":"最近遇到一个问题。具体内容是使用Volley联网请求一段json数据，用Postman工具获取返回数据也是正确的，在别人的电脑上也是正常的，返回数据header中编码格式也是utf-8.那么问题就出在volly这个工具类上了。 经过排查，发现问题确实出在volley的一个工具类上 。 HttpHeaderParser.parseCharset(response.headers); 利用StringRequst请求，获取数据的是这个方法 @Override protected Response&lt;String&gt; parseNetworkResponse(NetworkResponse response) { String parsed; try { parsed = new String(response.data, HttpHeaderParser.parseCharset(response.headers)); } catch (UnsupportedEncodingException e) { parsed = new String(response.data); } return Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response)); } 返回的是byte[]，byte[]转化为String需要指定编码格式。问题就是出现在这个编码格式上 /** * Returns the charset specified in the Content-Type of this header, * or the HTTP default (ISO-8859-1) if none can be found. */ public static String parseCharset(Map&lt;String, String&gt; headers) { String contentType = headers.get(HTTP.CONTENT_TYPE); if (contentType != null) { String[] params = contentType.split(&quot;;&quot;); for (int i = 1; i &lt; params.length; i++) { String[] pair = params[i].trim().split(&quot;=&quot;); if (pair.length == 2) { if (pair[0].equals(&quot;charset&quot;)) { return pair[1]; } } } } return HTTP.DEFAULT_CONTENT_CHARSET; } 这段代码会试图获取header中的编码格式。如果没获取到，就会返回默认的编码格式 iso.之所以出现乱码，就是因为返回了默认的编码iso，而没有正确的返回了header中包含的编码格式。 解决的办法很简单，就是重写 parseNetworkResponse(NetworkResponse response) 方法，手动的改为UTF-8编码 修改如下： @Override protected Response&lt;String&gt; parseNetworkResponse(NetworkResponse response) { String parsed; try { parsed = new String(response.data, &quot;UTF-8&quot;); } catch (UnsupportedEncodingException e) { parsed = new String(response.data); } return Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response)); } 参考： Volley 请求返回数据中文出现乱码 volley 获取cookie总结","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://tianqing.work/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://tianqing.work/tags/JAVA/"},{"name":"Volley","slug":"Volley","permalink":"http://tianqing.work/tags/Volley/"}]},{"title":"java int类型转换成String,不足10位在前面补0","slug":"java-int类型转换成String-不足10位在前面补0","date":"2017-05-09T12:51:02.000Z","updated":"2017-05-09T13:02:22.090Z","comments":true,"path":"2017/05/09/java-int类型转换成String-不足10位在前面补0/","link":"","permalink":"http://tianqing.work/2017/05/09/java-int类型转换成String-不足10位在前面补0/","excerpt":"","text":"String.format(“%010d”, 25); 0代表前面要补的字符 10代表字符串长度 d表示参数为整数类型","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://tianqing.work/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://tianqing.work/tags/JAVA/"},{"name":"基础","slug":"基础","permalink":"http://tianqing.work/tags/基础/"}]},{"title":"Android卸载测试应用后再次安装应用失败","slug":"Android卸载测试应用后再次安装应用失败","date":"2017-05-03T04:19:12.000Z","updated":"2017-05-03T04:35:35.483Z","comments":true,"path":"2017/05/03/Android卸载测试应用后再次安装应用失败/","link":"","permalink":"http://tianqing.work/2017/05/03/Android卸载测试应用后再次安装应用失败/","excerpt":"","text":"感谢阅读这篇博文，欢迎关注与评论！大家在做Android开发时，可能碰到这样的情况：把手机上的测试APP卸载后，再次安装就安装不上了。（博主的手机是魅族MX5，以前的时候从未碰到这种情况。） 解决方法： 在手机与电脑正常连接的情况下，调出命令行窗口。 输入：adb uninstall 包名 如：adb uninstall com.hd.soft.tjg 按 回车键 后 提示 Success 后，一般就可以正常安装了！","categories":[{"name":"Android","slug":"Android","permalink":"http://tianqing.work/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://tianqing.work/tags/Android/"}]},{"title":"JAVA学习之Struts2框架(二)","slug":"JAVA学习之Struts2框架-二","date":"2017-04-20T13:41:17.000Z","updated":"2017-04-20T13:56:25.710Z","comments":true,"path":"2017/04/20/JAVA学习之Struts2框架-二/","link":"","permalink":"http://tianqing.work/2017/04/20/JAVA学习之Struts2框架-二/","excerpt":"","text":"","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://tianqing.work/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://tianqing.work/tags/JAVA/"},{"name":"框架","slug":"框架","permalink":"http://tianqing.work/tags/框架/"},{"name":"Struts2","slug":"Struts2","permalink":"http://tianqing.work/tags/Struts2/"}]},{"title":"ADB的简单使用技巧（Android）","slug":"ADB命令简单使用技巧（Android）","date":"2017-04-16T12:52:52.000Z","updated":"2017-04-16T14:26:11.719Z","comments":true,"path":"2017/04/16/ADB命令简单使用技巧（Android）/","link":"","permalink":"http://tianqing.work/2017/04/16/ADB命令简单使用技巧（Android）/","excerpt":"感谢阅读这篇博文，欢迎关注与评论！ 连接手机和电脑的“脐带”，就是ADB——Android Debug Bridge。 ？？？？？此处为ADB的简单定义？？？？？？","text":"感谢阅读这篇博文，欢迎关注与评论！ 连接手机和电脑的“脐带”，就是ADB——Android Debug Bridge。 ？？？？？此处为ADB的简单定义？？？？？？ ADB基础ADB工具是位于SDK的`platfrom-tools`目录下，因此在命令行中使用ADB的时候，需要通过cd命令，切换到该目录下，或者将 platform-tools的路径添加到系统变量中，这样就可以直接使用了。配置好后，在命令行中输入以下命令。 如果显示如下内容，就说明配置成功了。 接着，在命令行中输入以下命令。 接下来就可以使用shell命令了。（不要问我这里Android这里为什么会出现shell，shell不是在Linux中的吗？因为Android就是就是Linux开发的！） ADB常用命令 显示系统中的全部Android平台 C：\\User\\Administrator&gt;android list targets 安装Apk程序（Install） adb install -r 应用程序.apk C：\\User\\Administrator&gt;adb install -r G:\\Test.apk 安装Apk程序（Push） adb push &lt;local&gt;&lt;remote&gt; C：\\User\\Administrator&gt;adb push G:\\Test.apk /system/app &gt; **区别:** 以上两种方法都可以将Apk安装到手机上，但也有不同。 1. adb Install 是将apk安装到 data/data 下，作为普通的用户应用程序。 2. adb push 不是安装命令，它是将一个文件写入到手机存储系统。因此，只要拥有相应的权限，就可以把任何apk放到任何目录下，甚至 放到System目录下，成为一个系统应用程序。 &gt; **adb push 补充：** 1. 向手机写入文件 adb push &lt;local&gt;&lt;remote&gt; C：\\User\\Administrator&gt;adb push G:\\Test.txt /system/temp/ 2. 从手机获取文件 adb push &lt;remote&gt;&lt;local&gt; C：\\User\\Administrator&gt;adb push /system/temp/ G:\\Test.txt 删除应用 adb remount （重新挂载系统分区，使系统分区重新可写） adb shell cd system/app rm *.apk 查看系统盘符 adb shell df 输出所有已经安装的应用 adb shell pm list packages -f 模拟按键输入 adb shell input keyevent C：\\User\\Administrator&gt;adb shell input keyevent 3 ps：82 menu 3 home 19 up 20 down 21 left 22 right 66 enter 4 back 模拟滑动输入 adb shell input touchscreen &lt;x1&gt;&lt;y1&gt;&lt;x2&gt;&lt;y2&gt; adb shell input touchscreen swipe 18 665 18 350 录制屏幕 adb shell screenrecord /sdcard/demo.mp4 重新启动 adb reboot 更多信息，大家可以去网上去查询！","categories":[{"name":"Android","slug":"Android","permalink":"http://tianqing.work/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://tianqing.work/tags/Android/"},{"name":"ADB","slug":"ADB","permalink":"http://tianqing.work/tags/ADB/"}]},{"title":"JAVA学习之Struts2框架（一）","slug":"JAVA学习之Struts2框架","date":"2017-04-15T12:52:52.000Z","updated":"2017-10-11T15:04:09.350Z","comments":true,"path":"2017/04/15/JAVA学习之Struts2框架/","link":"","permalink":"http://tianqing.work/2017/04/15/JAVA学习之Struts2框架/","excerpt":"Struts2简介Struts2概述Struts2是Apache发行的MVC开源框架。注意：它只是表现层（MVC）框架。 Struts2的来历 Struts1： 也是apache开发的一套mvc的开源框架。在2005年之前非常流行。 弊端：Struts1的核心控制器就是一个Servlet。随着使用者的增多，弊端开始出现。 Struts2：在long long ago，有一个设计超前的框架XWork，后来推出了XWork1和WebWork2。Struts2就是apache和OpenSymphony组织合并开发出来。里面包含了WebWork2的核心及Struts的一些特性和功能。除此之外，和Struts1没有任何关系了。","text":"Struts2简介Struts2概述Struts2是Apache发行的MVC开源框架。注意：它只是表现层（MVC）框架。 Struts2的来历 Struts1： 也是apache开发的一套mvc的开源框架。在2005年之前非常流行。 弊端：Struts1的核心控制器就是一个Servlet。随着使用者的增多，弊端开始出现。 Struts2：在long long ago，有一个设计超前的框架XWork，后来推出了XWork1和WebWork2。Struts2就是apache和OpenSymphony组织合并开发出来。里面包含了WebWork2的核心及Struts的一些特性和功能。除此之外，和Struts1没有任何关系了。 搭建Struts2开发环境下载Struts2开发包官网：http://struts.apache.org 由于国内网络比较好，所以说可能有时候打不开，可以百度一下，下载一份。 开发包目录结构 搭建开发环境拷贝必要jar包到classpath中 拷贝哪些jar包？ 找到Struts2自带的例子中，struts-blank的war包，在它的\\WEB-INF\\lib目录下的jar包全拷贝。 建立Struts2的配置文件 at the top of classpath（在最顶层的构建路径）,建立一个默认名称为struts.xml的配置文件。 struts.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt; &lt;struts&gt; &lt;/struts&gt; 注意： 文件名大小写。 创建位置。 该名称允许修改，但是我们一般不改。 配置控制器a、配置位置：在web.xml中 b、配置什么： struts2已经写好了的一个过滤器。 结论： struts2比struts1优秀的一个体现就是，它用了更为强大的过滤器作为控制器了。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt; &lt;display-name&gt;Struts2Template&lt;/display-name&gt; &lt;!-- 配置Struts核心控制器，就是一个过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; 验证是否成功部署应用，启动Tomcat，不报错表示搭建成功。 第一个Struts2案例 以下步骤是日后实际开发中经常重复的。 建立一个jsp文件index.jsp &lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Struts入门案例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;${pageContext.request.contextPath}/hello.action&quot;&gt;访问Struts的第一个入门案例&lt;/a&gt; &lt;a href=&quot;${pageContext.request.contextPath}/hello&quot;&gt;访问Struts的第一个入门案例&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 在struts.xml文件中配置struts.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt; &lt;struts&gt; &lt;package name=&quot;p1&quot; extends=&quot;struts-default&quot; &gt; &lt;!-- name:jsp对应的请求地址； class:指定一个动作类，在这里也就是给hello指定一个动作类 method: 对应hello要执行的方法。 --&gt; &lt;action name=&quot;hello&quot; class=&quot;cn.terry.web.action.HelloAction&quot; method=&quot;sayHello&quot;&gt; &lt;!-- 配置结果视图 --&gt; &lt;result name=&quot;success&quot;&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 建立动作类和动作方法HelloAction.java package cn.terry.web.action; public class HelloAction {//动作类 /** * 在动作类中的指定的动作方法 * 动作方法的书写要求： * 1、都是public的 * 2、返回值必须是一个String * 3、必须没有参数 * @return */ public String sayHello(){ System.out.println(&quot;HelloAction的sayHello方法执行了&quot;); return &quot;success&quot;;//与配置文件中result的name取值相对应 } } 结果视图页面success.jsp &lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt; &lt;!-- &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt; --&gt; &lt;/head&gt; &lt;body&gt; 操作成功 &lt;/body&gt; &lt;/html&gt; 测试：只要没有错误，这里就可以得到自己想要的结果。 关于struts.xml没有代码提示的问题分析原因：没有找到对应的dtd约束文件。 解决办法： 在网上找到struts的.dtd包，放到如图目录中，这个包在网上找就可以。 ok就可以了。 第一个案例的执行过程 Struts2的配置文件加载时机：当应用被tomcat加载的时候，struts2的配置文件就已经被加载过了。 加载顺序加载顺序：default.properties——struts-default.xml——plugins配置——struts.xml——struts.properties——web.xml 顺序配置文件名所在位置说明1default.propertiesstruts2-core-2.3.15.3.jar\\org\\apache\\struts2 不能修改2struts-default.xmlstruts2-core-2.3.15.3.jar 不能修改3strtuts-plugin.xml在struts2提供的插件jar包中 不能修改4struts.xml我们的应用中 我们修改的：推荐5struts.properties我们的应用中 我们修改的6web.xml我们的应用中 我们修改的，可以给过滤器配置参数 注意： 1、Struts2提供了两种配置的方式。一种是key=value的方式，即使用.properties文件。另一种是xml文件配置。我们推荐使用xml文件（它能描述层级关系）。 2、当多个配置文件中，有相同的参数，后面的会把前面的值给覆盖了。 Struts2框架提供的常量常用的常量常量定义在了default.properties配置文件中，体现形式都是key=value。所有的struts2应用都会用到这些常量。 常用的： 常量名常量值说明struts.i18n.encodingUTF-8应用中使用的编码struts.objectFactory.spring.autoWirename和spring框架整合有关struts.multipart.parser jakarta 指定文件上传用的组件struts.multipart.maxSize 2097152 文件上传总文件大小限制：2Mstruts.action.extension action 能进入Struts2框架内部的url地址后缀名。多个值用逗号分隔struts.enable.DynamicMethodInvocation false 是否允许动态方法调用struts.devMode false 是否是开发模式。开发模式：改了配置文件，不需要重启。输出更多的错误信息。开发阶段建议为true。struts.ui.theme xhtml 页面展示用的主题 在struts.xml中覆盖常量使用&lt;constant name=&quot;&quot; value=&quot;&quot;&gt;&lt;/constant&gt;元素进行覆盖 例如： &lt;!-- 修改struts中默认的后缀名 --&gt; &lt;constant name=&quot;struts.action.extension&quot; value=&quot;do&quot;&gt;&lt;/constant&gt; 创建struts.properties文件覆盖在应用的构建路径中创建一个struts.properties的文件。 struts.xml配置文件的主要元素package元素 属性： name：包的名称。必须写。且必须唯一。 extends：一般情况下需要继承struts-default包，但不是必须的。不过如果不继承的话，将无法使用struts2提供的核心功能。 struts-default.xml中定义着struts-default这个包。而struts-default.xml是在我们的struts.xml加载之前加载。 abstract：把包声明为抽象包，抽象包就是用来被继承的。只要是没有元素的包，就可以声明为抽象包。 namespace：名称空间。 `名称空间 + 动作名称 = 访问路径` struts.xml代码片段 &lt;!-- package元素：是定义一个struts的包，它是把配置文件按照面向对象的思想来管理。分模块开发。 name属性：包的名称。具有唯一性。 extends属性：指定当前包的父包。它是按照面向对象的思想管理的体现。 abstract属性：把包声明为一个抽象包。抽象包是用来被继承的。只有没有action元素的包才能被定义为抽象包。 namespace属性：名称空间。当指定了名称空间以后，访问路径就变成了： 访问路径 = 名称空间+动作名称。 当不指定该属性时，该属性有默认值，默认值是&quot;&quot;,不是&quot;/&quot;. --&gt; &lt;package name=&quot;p1&quot; extends=&quot;struts-default&quot; namespace=&quot;/user&quot;&gt; packege中的namespace详解 namespace的默认值： a.不写该属性 b.写了该属性，取值是一个&quot;&quot;.注意：默认值不是/ 动作类的搜索顺序： action元素 属性： name：动作名称 class：动作类全名。默认的动作类是：com.opensymphony.xwork2.ActionSupport,是在struts-default.xml中定义的,要想替换默认动作类：在应用的struts.xml中，package中加入： method：动作类中的方法名称。默认是public String execute(){} 要求： 1.public的 2.返回值必须是String 3.没有参数 struts.xml代码片段 &lt;!-- action元素：是用于定义动作名称，动作类和动作方法的映射。以及当出现不同情况时前往指定的结果视图。 name属性：动作名称。和jsp中请求的url中的名称对应起来。注意：此处不能写 .action class属性：指定的动作类。 method属性：动作类中的方法名称。默认是public String execute(){} 要求： 1.public的 2.返回值必须是String 3.没有参数 --&gt; &lt;action name=&quot;action1&quot; class=&quot;cn.terry.web.action.DemoAction1&quot; method=&quot;saveUser&quot;&gt; 动作类 a.方式一：动作类就是一个POJO（Plain Old Java Object 原始的java对象），非常简单的javabean。 b.方式二：动作类实现com.opensymphony.xwork2.Action接口。 常量：给动作方法返回值用的。用常量可以使你的应用规范和统一。 常量变量名 对应的值 说明SUCCESS success 动作方法执行一切OKERROR error 动作方法执行时遇到了异常INPUT input 回显LOGIN login 一般转向登陆页面NONE none 不转向任何的视图 c.方式三：动作类继承com.opensymphony.xwork2.ActionSupport 推荐使用 动作的访问 a.使用通配符： 升级版： 优先级：绝对匹配优先。使用通配符的按照在配置文件中的先后顺序进行匹配的。 b.动态方法调用 result元素 属性： name：逻辑视图的名称，对应着动作方法的返回值。默认值是success。 type：结果类型，指的就是用什么方式转到定义的页面。默认是dispatcher。 struts.xml &lt;!-- result元素：配置逻辑结果视图； name属性：逻辑视图的名称，对应着动作方法的返回值。默认值是success。 type：结果类型，指的就是用什么方式转到定义的页面。默认是dispatcher。 常用取值： dispatcher：(默认值) 使用请求转发，转向一个页面。 redirect： 使用重定向，转向一个页面。 --&gt; &lt;result name=&quot;success&quot;&gt;/success.jsp&lt;/result&gt; result元素中type的取值 常用结果类型介绍： dispatcher：(默认值)使用请求转发，转向一个页面。 redirect：使用重定向，转向一个页面。 redirectAction：注意：使用的是重定向。 a.重定向到另一个相同名称空间的动作。 b.重定向到不同名称空间的动作 chain：注意： 使用的是请求转发。 a.转发到另一个相同名称空间的动作。 b.请求转发到不同名称空间的动作","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://tianqing.work/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://tianqing.work/tags/JAVA/"},{"name":"框架","slug":"框架","permalink":"http://tianqing.work/tags/框架/"},{"name":"Struts2","slug":"Struts2","permalink":"http://tianqing.work/tags/Struts2/"}]},{"title":"JAVA学习之框架前述","slug":"JAVA学习之框架前述","date":"2017-04-15T09:50:03.000Z","updated":"2017-04-15T10:11:31.294Z","comments":true,"path":"2017/04/15/JAVA学习之框架前述/","link":"","permalink":"http://tianqing.work/2017/04/15/JAVA学习之框架前述/","excerpt":"本篇文章是对学习框架前的开题篇。 内容为： 框架概述 三层架构 控制器：MVC中的控制器 案例中的问题","text":"本篇文章是对学习框架前的开题篇。 内容为： 框架概述 三层架构 控制器：MVC中的控制器 案例中的问题 框架概述框架的意义与作用： 所谓框架，就是把一些繁琐的重复性代码封装起来，使程序员在编码中把更多的经历放到业务需求的分析和理解上面。 特点：封装了很多细节，程序员在使用的时候会非常简单。 三层架构 表现层：M model V view C control 业务层：service 持久层：dao data access object Struts2在三层架构中的位置是处于表现层。Struts2只是一个表现层框架。 控制器：MVC中的控制器MVC回顾M：Model 模型，封装数据。javabean V：view 视图，展示界面。jsp C：Controller 控制器，控制程序流程。Servlet Servlet和FilterServlet: Filter： 总结： Servlet能做的事情，过滤器也可以做到。并且过滤器比Servlet还多了一个放行的功能，因此过滤器比Servlet功能更为强大。结论就是：过滤器同样也适合做控制器。 案例中的问题 规律： 1. 获取请求正文，用户要做什么事情 2. 根据不同的请求，做出不同的判断 3. 执行具体的方法代码（*动作*） 4. 转向页面，展示给用户 缺陷： 1. 重复性劳动太多，具体的执行代码也有冗余代码。 2. 到底要做什么全是硬编码，像用户要做什么事情，对应执行什么代码，可以写在配置文件中。 3. 具体的代码方法放到了控制器中，过于臃肿。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://tianqing.work/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://tianqing.work/tags/JAVA/"},{"name":"框架","slug":"框架","permalink":"http://tianqing.work/tags/框架/"}]},{"title":"JAVA学习之常用的数据源配置","slug":"JAVA学习之常用的数据源配置","date":"2017-04-02T12:39:01.000Z","updated":"2017-04-15T09:43:46.203Z","comments":true,"path":"2017/04/02/JAVA学习之常用的数据源配置/","link":"","permalink":"http://tianqing.work/2017/04/02/JAVA学习之常用的数据源配置/","excerpt":"常用的数据源配置： DBCP C3P0 用JavaWeb服务器管理数据源：Tomcat","text":"常用的数据源配置： DBCP C3P0 用JavaWeb服务器管理数据源：Tomcat DBCP DBCP：Apache推出的Database Connection Pool 使用步骤： 添加jar包: commons-dbcp-1.4.jar commons-pool-1.5.6.jar (这两个jar包网上一搜有很多，如果找不到合适的，读者可以email我，我发给大家！) 添加属性资源文件 编写数据源工具类 简例架构： 添加属性资源文件： dbcpconfig.properties 注：这个文件也是去网上搜索，拿来直接用就可以了。 dbcpconfig.properties 连接设置 driverClassName=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/day16 username=root password= &lt;!-- 初始化连接 --&gt; initialSize=10 最大连接数量 maxActive=50 &lt;!-- 最大空闲连接 --&gt; maxIdle=20 &lt;!-- 最小空闲连接 --&gt; minIdle=5 &lt;!-- 超时等待时间以毫秒为单位 6000毫秒/1000等于60秒 --&gt; maxWait=60000 JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：[属性名=property;] 注意：&quot;user&quot; 与 &quot;password&quot; 两个属性会被明确地传递，因此这里不需要包含他们。 connectionProperties=useUnicode=true;characterEncoding=utf8 指定由连接池所创建的连接的自动提交（auto-commit）状态。 defaultAutoCommit=true driver default 指定由连接池所创建的连接的只读（read-only）状态。 如果没有设置该值，则“setReadOnly”方法将不被调用。（某些驱动并不支持只读模式，如：Informix） defaultReadOnly= driver default 指定由连接池所创建的连接的事务级别（TransactionIsolation）。 可用值为下列之一：（详情可见javadoc。）NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE defaultTransactionIsolation=REPEATABLE_READ 编写数据源工具类 DBCPUtil.java package cn.terry.utils; import java.io.IOException; import java.security.spec.DSAGenParameterSpec; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.util.Properties; import javax.sql.DataSource; import org.apache.commons.dbcp.BasicDataSourceFactory; public class DBCPUtil { private static DataSource ds = null; static{ Properties prop = new Properties(); //根据DBCPUtil的classes的路径，加载配置文件 try { prop.load(DBCPUtil.class.getClassLoader().getResourceAsStream(&quot;dbcpconfig.properties&quot;)); ds = BasicDataSourceFactory.createDataSource(prop);//得到一个数据源 } catch (Exception e) { throw new ExceptionInInitializerError(&quot;初始化错误，请检查配置文件&quot;); } } public static Connection getConnection() { try { return ds.getConnection(); } catch (SQLException e) { throw new RuntimeException(&quot;服务器忙。。。&quot;); } } public static void release(Connection conn,Statement stmt,ResultSet rs){ //关闭资源 if(rs!=null){ try { rs.close(); } catch (Exception e) { e.printStackTrace(); } rs = null; } if(stmt!=null){ try { stmt.close(); } catch (Exception e) { e.printStackTrace(); } stmt = null; } if(conn!=null){ try { conn.close();//关闭 } catch (Exception e) { e.printStackTrace(); } conn = null; } } } testJDBC.java package cn.terry.test; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.SQLException; import org.junit.Test; import cn.terry.utils.DBCPUtil; public class testJDBC { @Test public void test1() { Connection conn = null; PreparedStatement ps = null; try { conn = DBCPUtil.getConnection(); ps = conn.prepareStatement(&quot;..&quot;); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); }finally { DBCPUtil.release(conn, ps, null); } } } C3P0这个是建立的java项目。 简例结构图： 使用步骤： 1、添加jar包 jar包也是去网上搜。 2、编写配置文件 c3p0-config.xml，放在classpath中，或classes目录中 c3p0-config.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;c3p0-config&gt; &lt;default-config&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/mytest&lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxIdleTime&quot;&gt;30&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;100&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt; &lt;/default-config&gt; &lt;/c3p0-config&gt; 3、编写工具类： C3P0Util.java package cn.terry.utils; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import javax.sql.DataSource; import com.mchange.v2.c3p0.ComboPooledDataSource; public class C3P0Util { //得到一个数据源 private static DataSource dataSource = new ComboPooledDataSource(); //从数据源中得到一个连接对象 public static Connection getConnection(){ try { return dataSource.getConnection(); } catch (SQLException e) { throw new RuntimeException(&quot;服务器错误&quot;); } } public static void release(Connection conn,Statement stmt,ResultSet rs){ //关闭资源 if(rs!=null){ try { rs.close(); } catch (Exception e) { e.printStackTrace(); } rs = null; } if(stmt!=null){ try { stmt.close(); } catch (Exception e) { e.printStackTrace(); } stmt = null; } if(conn!=null){ try { conn.close();//关闭 } catch (Exception e) { e.printStackTrace(); } conn = null; } } } TestCRUD.java package cn.terry.utils; import java.sql.Connection; import java.sql.PreparedStatement; import org.junit.Test; public class TestCRUD { @Test public void testInsert(){ Connection conn = null; PreparedStatement ps = null; try { conn = C3P0Util.getConnection(); ps = conn.prepareStatement(&quot;insert into account(name,money) values(&apos;ggg&apos;,2000)&quot;); ps.executeUpdate(); } catch (Exception e) { e.printStackTrace(); }finally{ C3P0Util.release(conn, ps, null); } System.out.println(conn.getClass().getName()); } } 用JavaWeb服务器管理数据源：Tomcat开发JavaWeb应用，必须使用一个JavaWeb服务器，JavaWeb服务器都内置数据源。 Tomcat：（DBCP） 数据源只需要配置服务器即可。 配置数据源的步骤： 1、拷贝数据库连接的jar到tomcatlib目录下 2、配置数据源XML文件 (全局配置)如果把配置信息写在tomcat下的conf目录的context.xml中，那么所有应用都能使用此数据源。 1）在tomcat的conf文件夹下的context.xml配置文件中加入： &lt;Resource name=&quot;jndi/mybatis&quot; auth=&quot;Container&quot; type=&quot;javax.sql.DataSource&quot; driverClassName=&quot;com.mysql.jdbc.Driver&quot; url=&quot;jdbc:mysql://localhost:3306/appdb&quot; username=&quot;root&quot; password=&quot;123456&quot; maxActive=&quot;20&quot; maxIdle=&quot;10&quot; maxWait=&quot;10000&quot;/&gt; 2)在项目的web.xml中加入资源引用： &lt;resource-ref&gt; &lt;description&gt;JNDI DataSource&lt;/description&gt; &lt;res-ref-name&gt;jndi/mybatis&lt;/res-ref-name&gt; &lt;res-ref-type&gt;javax.sql.DataSource&lt;/res-ref-type&gt; &lt;res-auth&gt;Container&lt;/res-auth&gt; &lt;/resource-ref&gt; 其中res-ref-name值要和context.xml的name值一致。 3）jndi测试方法： public void testJNDI() throws NamingException, SQLException{ Context ctx = new InitialContext(); DataSource ds = (DataSource) ctx.lookup(&quot;java:comp/env/jndi/mybatis&quot;); Connection conn = ds.getConnection(); System.out.println(conn.isClosed()); } 4）在jsp中调用加载jndi方式，不可以直接用main方法测试，必须通过启动容器从jsp中调用： TestPageAccessURL test = new TestPageAccessURL(); test.testJNDI(); （局部配置1）如果是在当前应用的META-INF中创建context.xml, 编写数据源，那么只有当前应用可以使用。 1）在项目的META-INFO下面新建context.xml。加入： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;Context&gt; &lt;Resource name=&quot;jndi/mybatis&quot; auth=&quot;Container&quot; type=&quot;javax.sql.DataSource&quot; driverClassName=&quot;com.mysql.jdbc.Driver&quot; url=&quot;jdbc:mysql://localhost:3306/appdb&quot; username=&quot;root&quot; password=&quot;123456&quot; maxActive=&quot;20&quot; maxIdle=&quot;10&quot; maxWait=&quot;10000&quot;/&gt; &lt;/Context&gt; 其他配置同第一种方式。 局部配置2（不推荐）。 1）在tomcat的server.xml的标签内，添加： &lt;Context path=&quot;/demo_jndi&quot; docBase=&quot;/demo_jndi&quot;&gt; &lt;Resource name=&quot;jndi/mybatis&quot; type=&quot;javax.sql.DataSource&quot; driverClassName=&quot;com.mysql.jdbc.Driver&quot; maxIdle=&quot;2&quot; maxWait=&quot;5000&quot; username=&quot;root&quot; password=&quot;123456&quot; url=&quot;jdbc:mysql://localhost:3306/appdb&quot; maxActive=&quot;4&quot;/&gt; &lt;/Context&gt; 其他配置同第一种方式。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://tianqing.work/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://tianqing.work/tags/JAVA/"},{"name":"连接池","slug":"连接池","permalink":"http://tianqing.work/tags/连接池/"}]},{"title":"JAVA学习之Jsp","slug":"JAVA学习之Jsp","date":"2017-03-29T12:41:07.000Z","updated":"2017-04-15T09:23:31.278Z","comments":true,"path":"2017/03/29/JAVA学习之Jsp/","link":"","permalink":"http://tianqing.work/2017/03/29/JAVA学习之Jsp/","excerpt":"Jsp 简介 JSP全称是Java Server Pages，它和servle技术一样，都是SUN公司定义的一种用于开发动态web资源的技术。JSP实际上就是Servlet。 jsp = html + java html:静态内容 servlet：服务器端的小应用程序。适合编写java逻辑代码，如果编写网页内容–苦逼。 jsp:适合编写输出动态内容，但不适合编写java逻辑。","text":"Jsp 简介 JSP全称是Java Server Pages，它和servle技术一样，都是SUN公司定义的一种用于开发动态web资源的技术。JSP实际上就是Servlet。 jsp = html + java html:静态内容 servlet：服务器端的小应用程序。适合编写java逻辑代码，如果编写网页内容–苦逼。 jsp:适合编写输出动态内容，但不适合编写java逻辑。 jsp的原理 JSP 语法(3、6、9) 接下来就是JSP的3（jsp的3个指令）6（jsp的6个动作）9（jsp的9个内置对象）了，简称：三六九。 JSP的脚本 小脚本: &lt;% java代码 %&gt; 表达式: &lt;%= 2+3 %&gt; 等价于out.print(2+3); 声明: &lt;%! %&gt; 表示在类中定义全局成员，和静态块。 1、脚本程序的语法格式及示例： &lt;% 代码片段 %&gt; &lt;% out.println(&quot;Your IP address is &quot; + request.getRemoteAddr()); %&gt; 2、表达式示例： &lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;ISO-8859-1&quot;%&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;% Date date = new Date(); out.write(date.toLocaleString()); %&gt; &lt;/body&gt; &lt;/html&gt; 3、声明示例： 一个声明语句可以声明一个或多个变量、方法，供后面的Java代码使用。在JSP文件中，您必须先声明这些变量和方法然后才能使用它们。 &lt;%! int i = 0; %&gt; &lt;%! int a, b, c; %&gt; &lt;%! Circle a = new Circle(2.0); %&gt; JSP 指令（3）JSP中的三种指令标签： 指令 描述 page 定义网页依赖属性，比如脚本语言、error页面、缓存需求等等 include 包含其他文件 taglib 引入标签库的定义 Page指令 Page指令为容器提供当前页面的使用说明。一个JSP页面可以包含多个page指令。 Page指令的语法格式： &lt;%@ 指令名称 属性1=“属性值1” 属性2=“属性值2”。。。%&gt; 或者： &lt;%@ 指令名称 属性1=“属性值1”%&gt; &lt;%@ 指令名称 属性2=“属性值2”%&gt; 如： &lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt; 或者： &lt;%@ page language=&quot;java&quot; %&gt; &lt;%@ page import=&quot;java.util.*&quot; %&gt; 与Page指令相关的属性： 属性 描述buffer JSP中有javax.servlet.jsp.JspWriter输出字符流。指定out对象使用缓冲区的大小,默认是8kb.autoFlush 控制out对象的 缓存区contentType 指定当前JSP页面的MIME类型和字符编码，等同于response.setContextType(“text/html;charset=utf-8”);errorPage 指定当JSP页面发生异常时需要转向的错误处理页面isErrorPage 指定当前页面是否可以作为另一个JSP页面的错误处理页面，默认是false。extends 指定servlet从哪一个类继承import 导入要使用的Java类,和java代码中的import是一样的info 定义JSP页面的描述信息isThreadSafe 指定对JSP页面的访问是否为线程安全language 定义JSP页面所用的脚本语言，默认是Javasession 指定JSP页面是否使用session,默认值是trueisELIgnored 指定是否执行EL表达式isScriptingEnabled 确定脚本元素能否被使用pageEncoding 告诉JSP引擎要翻译的文件使用的编码 注： errorPage：errorPage=”/uri” 如果写“/”则代表当前应用的目录下，绝对路径。如果不写“/”则代表相对路径。 include指令 JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。 静态包含：把其它资源包含到当前页面中。 &lt;%@ include file=&quot;/include/header.jsp&quot; %&gt; 动态包含： &lt;jsp:include page=&quot;/include/header.jsp&quot;&gt;&lt;/jsp:include&gt; 两者的区别：翻译的时间段不同 前者：在翻译时就把两个文件合并 后者：不会合并文件，当代码执行到include时，才包含另一个文件的内容。 原则：能用静的就不用动的。 taglib指令作用：在JSP页面中导入JSTL标签库。替换jsp中的java代码片段。 &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; JSP 动作元素（6） 使用标签的形式来表示一段java代码。 &lt;jsp:include &gt; 动态包含 &lt;jsp:forward&gt; 请求转发 &lt;jsp:param&gt; 设置请求参数 &lt;jsp:useBean&gt; 创建一个对象 &lt;jsp:setProperty&gt; 给指定的对象属性赋值 &lt;jsp:getProperty&gt; 取出指定对象的属性值 动作元素(jsp:include) 动作元素用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。 语法格式如下： &lt;jsp:include page=&quot;相对 URL 地址&quot; flush=&quot;true&quot; /&gt; 属性 描述page 包含在页面中的相对URL地址。flush 布尔属性，定义在包含资源前是否刷新缓存区。 实例: date.jsp文件代码： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;p&gt; 今天的日期是: &lt;%= (new java.util.Date()).toLocaleString()%&gt; &lt;/p&gt; main.jsp文件代码： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;123&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;include 动作实例&lt;/h2&gt; &lt;jsp:include page=&quot;date.jsp&quot; flush=&quot;true&quot; /&gt; &lt;/body&gt; &lt;/html&gt; 动作元素(jsp:useBean)jsp:useBean动作最简单的语法为： &lt;!-- 模板 --&gt; &lt;jsp:useBean id=&quot;name&quot; class=&quot;package.class&quot; /&gt; &lt;!-- 示例 --&gt; &lt;jsp:useBean id=&quot;stu1&quot; class=&quot;com.itheima.entity.Student&quot;&gt;&lt;/jsp:useBean&gt; 注： class中填写的是Bean类的完整路径 id 为定义的的Bean变量名，如 Bean b = new Bean()中的b; 动作元素(jsp:setProperty) jsp:setProperty用来设置已经实例化的Bean对象的属性. &lt;jsp:setProperty property=&quot;name&quot; name=&quot;stu1&quot; value=&quot;jerry&quot;/&gt; jsp:setProperty动作有下面四个属性,如下表： 属性 描述name name属性是必需的。它表示要设置属性的是哪个Bean。property property属性是必需的。它表示要设置哪个属性。有一个特殊用法：如果property的值是”*”，表示所有名字和Bean属性名字匹配的请求参数都将被传递给相应的属性set方法。value value 属性是可选的。该属性用来指定Bean属性的值。字符串数据会在目标类中通过标准的valueOf方法自动转换成数字、boolean、Boolean、 byte、Byte、char、Character。例如，boolean和Boolean类型的属性值（比如”true”）通过 Boolean.valueOf转换，int和Integer类型的属性值（比如”42”）通过Integer.valueOf转换。 value和param不能同时使用，但可以使用其中任意一个。param param 是可选的。它指定用哪个请求参数作为Bean属性的值。如果当前请求没有参数，则什么事情也不做，系统不会把null传递给Bean属性的set方法。因此，你可以让Bean自己提供默认属性值，只有当请求参数明确指定了新值时才修改默认属性值。 动作元素(jsp:getProperty) jsp:getProperty动作提取指定Bean属性的值，转换成字符串，然后输出。 语法格式如下： &lt;jsp:getProperty property=&quot;name&quot; name=&quot;stu1&quot;/&gt; 下表是与getProperty相关联的属性： 属性 描述name 要检索的Bean属性名称。Bean必须已定义。property 表示要提取Bean属性的值 实例： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;useBean&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;Jsp 使用 JavaBean 实例&lt;/h2&gt; &lt;jsp:useBean id=&quot;test&quot; class=&quot;com.runoob.main.TestBean&quot; /&gt; &lt;jsp:setProperty name=&quot;test&quot; property=&quot;message&quot; value=&quot;教程...&quot; /&gt; &lt;p&gt;输出信息....&lt;/p&gt; &lt;jsp:getProperty name=&quot;test&quot; property=&quot;message&quot; /&gt; &lt;/body&gt; &lt;/html&gt; 动作元素(jsp:forward) jsp:forward动作把请求转到另外的页面。jsp:forward标记只有一个属性page。 语法格式如下所示： &lt;jsp:forward page=&quot;相对 URL 地址&quot; /&gt; 以下是forward相关联的属性： 属性 描述page page属性包含的是一个相对URL。page的值既可以直接给出，也可以在请求的时候动态计算，可以是一个JSP页面或者一个 Java Servlet. 实例date.jsp 文件代码如下： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;p&gt; 今天的日期是: &lt;%= (new java.util.Date()).toLocaleString()%&gt; &lt;/p&gt; main.jsp文件代码： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;forward 动作实例&lt;/h2&gt; &lt;jsp:forward page=&quot;date.jsp&quot; /&gt; &lt;/body&gt; &lt;/html&gt; JSP 隐式对象(9) JSP隐式对象是JSP容器为每个页面提供的Java对象，开发者可以直接使用它们而不用显式声明。JSP隐式对象也被称为预定义变量。 JSP所支持的九大隐式对象： 对象 描述request HttpServletRequest类的实例,它包含了有关浏览器请求的信息，并且提供了几个用于获取cookie, header, 和session数据的有用的方法。response HttpServletResponse类的实例，并提供了几个用于设置送回浏览器的响应的方法（如cookies,头信息等）。out PrintWriter类的实例，用于把结果输出至网页上session HttpSession类的实例,Session可以存贮用户的状态信息。application ServletContext类的实例，与应用上下文有关,有助于查找有关servlet引擎和servlet环境的信息。config ServletConfig类的实例,该对象用于存取servlet实例的初始化参数。pageContext PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问page 类似于Java类中的this关键字，表示从该页面产生的一个servlet实例。Exception Exception类的对象，代表发生错误的JSP页面中对应的异常对象 pageContext(重要):1、本身也是一个域对象：它可以操作其它三个域对象（request session application）的数据. 四大域对象PageContext : pageConext 存放的数据在当前页面有效。开发时使用较少。 ServletRequest: request 存放的数据在一次请求（转发）内有效。使用非常多。 HttpSession: session 存放的数据在一次会话中有效。使用的比较多。如：存放用户的登录信息，购物车功能。 ServletContext: application 存放的数据在整个应用范围内都有效。因为范围太大，应尽量少用。 EL表达式EL概述和基本语法 EL表达式：expression language 表达式语言 要简化jsp中java代码开发。 它不是一种开发语言，是jsp中获取数据的一种规范 基本语法如下： ${表达式} EL中的基础操作符操作符 描述. 访问一个Bean属性或者一个映射条目[] 访问一个数组或者链表的元素( ) 组织一个子表达式以改变优先级+ 加- 减或负* 乘/ or div 除% or mod 取模A?B:C 执行某种条件判断== or eq 测试是否相等!= or ne 测试是否不等&lt; or lt 测试是否小于&gt; or gt 测试是否大于&lt;= or le 测试是否小于等于&gt;= or ge 测试是否大于等于&amp;&amp; or and 测试逻辑与|| or or 测试逻辑或! or not 测试取反empty 测试是否空值 补： EL表达式中的empty运算符用于判断某个对象是否为null或””，结果为布尔类型，语法格式如下： ${empty var} 下列情况empty返回值为true。 var变量不存在，即没有定义，例如表达式${empty name},如果不存在 name 变量，就返回 true。 var变量的值为null，例如表达式 ${empty customer.name},如果customer.name的值为null，就返回true. var变量引用集合（Set、Map、List）类型对象，并且在集合对象中不包含任何元素。 防止HTML注入displayMessage.jsp &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;servlet/ResultServlet&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 留言： &lt;textarea rows=&quot;6&quot; cols=&quot;50&quot; name=&quot;message&quot;&gt;&lt;/textarea&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; ResultServlet.java package com.tq.servlet; import java.io.IOException; import java.io.PrintWriter; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class ResultServlet extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doPost(request,response); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(&quot;UTF-8&quot;); String name = request.getParameter(&quot;username&quot;); String message = request.getParameter(&quot;message&quot;); request.setAttribute(&quot;name&quot;, name); request.setAttribute(&quot;message&quot;, message); request.getRequestDispatcher(&quot;/result.jsp&quot;).forward(request, response); } } HTMLFilter.java package com.tq.util; public class HTMLFilter { public static String filter(String message){ if (message==null) { return (null); } char content[] = new char[message.length()]; message.getChars(0, message.length(), content, 0); StringBuffer result = new StringBuffer(content.length); for (int i = 0; i &lt; content.length; i++) { switch (content[i]) { case &apos;&lt;&apos;: result.append(&quot;&amp;lt;&quot;); break; case &apos;&gt;&apos;: result.append(&quot;&amp;gt;&quot;); break; case &apos;&amp;&apos;: result.append(&quot;&amp;amp;&quot;); break; case &apos;&quot;&apos;: result.append(&quot;&amp;quot;&quot;); break; default: result.append(content[i]); break; } } return (result.toString()); } } mytaglib.tld &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd&quot; version=&quot;2.0&quot;&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;function&lt;/short-name&gt; &lt;uri&gt;http://www.mutouspace.cn&lt;/uri&gt; &lt;function&gt; &lt;name&gt;filter&lt;/name&gt; &lt;function-class&gt; com.tq.util.HTMLFilter &lt;/function-class&gt; &lt;function-signature&gt; java.lang.String filter(java.lang.String) &lt;/function-signature&gt; &lt;/function&gt; &lt;/taglib&gt; result.jsp &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix = &quot;terry&quot; uri=&quot;http://www.mutouspace.cn&quot; %&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 用户名:${name}&lt;br&gt; 留言：${terry:filter(message)} &lt;/body&gt; &lt;/html&gt; JSP 标准标签库（JSTL）待补充。。。。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://tianqing.work/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://tianqing.work/tags/JAVA/"},{"name":"JSP","slug":"JSP","permalink":"http://tianqing.work/tags/JSP/"}]},{"title":"JAVA学习之Servlet","slug":"JAVA之Servlet","date":"2017-03-25T15:31:16.000Z","updated":"2017-04-15T09:25:40.639Z","comments":true,"path":"2017/03/25/JAVA之Servlet/","link":"","permalink":"http://tianqing.work/2017/03/25/JAVA之Servlet/","excerpt":"Servlet 简介 Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 Servlet 任务 读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。 读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。 处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。 发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。 发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。","text":"Servlet 简介 Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 Servlet 任务 读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。 读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。 处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。 发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。 发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。 Servlet 生命周期public class ServletDemo1 implements Servlet{ //Servlet生命周期方法 //实例化 //在Servlet第一次访问时调用 public ServletDemo1(){ System.out.println(&quot;*************ServletDemo1执行了***************&quot;); } //Servlet生命周期方法 //初始化 //在Servlet第一次访问时调用,在后续每次用户请求时不再调用 @Override public void init(ServletConfig arg0) throws ServletException { System.out.println(&quot;*************init执行了***************&quot;); } //Servlet生命周期方法 //服务 //每次访问时都调用 @Override public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException { System.out.println(&quot;*************service执行了***************&quot;); } //Servlet生命周期方法 //销毁 @Override public void destroy() { System.out.println(&quot;*************destroy执行了***************&quot;); } @Override public ServletConfig getServletConfig() { // TODO Auto-generated method stub return null; } @Override public String getServletInfo() { // TODO Auto-generated method stub return null; } } HTTP 状态码代码 消息 描述100 Continue 只有请求的一部分已经被服务器接收，但只要它没有被拒绝，客户端应继续该请求。101 Switching Protocols 服务器切换协议。200 OK 请求成功。201 Created 该请求是完整的，并创建一个新的资源。202 Accepted 该请求被接受处理，但是该处理是不完整的。203 Non-authoritative Information 204 No Content 205 Reset Content 206 Partial Content 300 Multiple Choices 链接列表。用户可以选择一个链接，进入到该位置。最多五个地址。301 Moved Permanently 所请求的页面已经转移到一个新的 URL。302 Found 所请求的页面已经临时转移到一个新的 URL。303 See Other 所请求的页面可以在另一个不同的 URL 下被找到。304 Not Modified 305 Use Proxy 306 Unused 在以前的版本中使用该代码。现在已不再使用它，但代码仍被保留。307 Temporary Redirect 所请求的页面已经临时转移到一个新的 URL。400 Bad Request 服务器不理解请求。401 Unauthorized 所请求的页面需要用户名和密码。402 Payment Required 您还不能使用该代码。403 Forbidden 禁止访问所请求的页面。404 Not Found 服务器无法找到所请求的页面。.405 Method Not Allowed 在请求中指定的方法是不允许的。406 Not Acceptable 服务器只生成一个不被客户端接受的响应。407 Proxy Authentication Required 在请求送达之前，您必须使用代理服务器的验证。408 Request Timeout 请求需要的时间比服务器能够等待的时间长，超时。409 Conflict 请求因为冲突无法完成。410 Gone 所请求的页面不再可用。411 Length Required “Content-Length” 未定义。服务器无法处理客户端发送的不带 Content-Length 的请求信息。412 Precondition Failed 请求中给出的先决条件被服务器评估为 false。413 Request Entity Too Large 服务器不接受该请求，因为请求实体过大。414 Request-url Too Long 服务器不接受该请求，因为 URL 太长。当您转换一个 “post” 请求为一个带有长的查询信息的 “get” 请求时发生。415 Unsupported Media Type 服务器不接受该请求，因为媒体类型不被支持。417 Expectation Failed 500 Internal Server Error 未完成的请求。服务器遇到了一个意外的情况。501 Not Implemented 未完成的请求。服务器不支持所需的功能。502 Bad Gateway 未完成的请求。服务器从上游服务器收到无效响应。503 Service Unavailable 未完成的请求。服务器暂时超载或死机。504 Gateway Timeout 网关超时。505 HTTP Version Not Supported 服务器不支持”HTTP协议”版本。 设置 HTTP 状态代码的方法序号 方法 &amp; 描述1 public void setStatus ( int statusCode )该方法设置一个任意的状态码。setStatus 方法接受一个 int（状态码）作为参数。如果您的反应包含了一个特殊的状态码和文档，请确保在使用 PrintWriter 实际返回任何内容之前调用 setStatus。2 public void sendRedirect(String url)该方法生成一个 302 响应，连同一个带有新文档 URL 的 Location 头。3 public void sendError(int code, String message)该方法发送一个状态码（通常为 404），连同一个在 HTML 文档内部自动格式化并发送到客户端的短消息。 HTTP 状态码实例// 扩展 HttpServlet 类 public class showError extends HttpServlet { // 处理 GET 方法请求的方法 public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 设置错误代码和原因 response.sendError(407, &quot;Need authentication!!!&quot; ); } // 处理 POST 方法请求的方法 public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } CookieCookie实例： public class Cookie01 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doPost(request, response); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { getCookie(request, response); } //通过Servlet获取Cookie private void getCookie(HttpServletRequest request, HttpServletResponse response) throws UnsupportedEncodingException { Cookie cookie = null; Cookie[] cookies = null; // 获取与该域相关的 Cookie 的数组 cookies = request.getCookies(); // 设置响应内容类型 response.setContentType(&quot;text/html;charset=UTF-8&quot;); if( cookies != null ){ for (int i = 0; i &lt; cookies.length; i++){ cookie = cookies[i]; if((cookie.getName( )).compareTo(&quot;name&quot;) == 0 ){ cookie.setMaxAge(0); response.addCookie(cookie); System.out.println(&quot;已删除的 cookie：&quot; + cookie.getName( )); } System.out.println(&quot;名称：&quot; + cookie.getName( ) + &quot;,&quot;); System.out.println(&quot;值：&quot; + URLDecoder.decode(cookie.getValue(), &quot;utf-8&quot;)); } } } //设置Cookie private void setCookie(HttpServletRequest request, HttpServletResponse response) throws UnsupportedEncodingException, IOException { // 为名字和姓氏创建 Cookie Cookie name = new Cookie(&quot;name&quot;, URLEncoder.encode(request.getParameter(&quot;name&quot;), &quot;UTF-8&quot;)); // 中文转码 Cookie url = new Cookie(&quot;url&quot;, request.getParameter(&quot;url&quot;)); // 为两个 Cookie 设置过期日期为 24 小时后 name.setMaxAge(60*60*24); url.setMaxAge(60*60*24); // 在响应头中添加两个 Cookie response.addCookie(name); response.addCookie(url); // 设置响应内容类型 response.setContentType(&quot;text/html;charset=UTF-8&quot;); System.out.println(request.getParameter(&quot;name&quot;)); System.out.println(request.getParameter(&quot;url&quot;) ); } } html文件： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=servlet/cookie01 method=&quot;GET&quot;&gt; 站点名 ：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;br /&gt; 站点 URL：&lt;input type=&quot;text&quot; name=&quot;url&quot; /&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 文件下载：java文件： import java.io.FileInputStream; import java.io.IOException; import java.io.PrintWriter; import java.net.URLEncoder; import javax.servlet.ServletException; import javax.servlet.ServletOutputStream; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * 文件下载 * @author tianq * */ public class ServletDemo5 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doPost(request,response); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //通过路径得到一个输入流 String path = this.getServletContext().getRealPath(&quot;WEB-INF/classes/美景.jpg&quot;); FileInputStream fis = new FileInputStream(path); //创建字节输出流 ServletOutputStream sos = response.getOutputStream(); //得到要下载的文件名 String fileName = path.substring(path.lastIndexOf(&quot;\\\\&quot;)+1); //设置文件名编码 fileName = URLEncoder.encode(fileName, &quot;UTF-8&quot;); //告知客户端下载 response.setHeader(&quot;content-disposition&quot;, &quot;attachment;filename=&quot;+fileName); response.setHeader(&quot;content-type&quot;, &quot;image/jpeg&quot;); //执行输出操作 int len = 1; byte[] b = new byte[1024]; while ((len=fis.read(b))!=-1) { sos.write(b, 0, len); } } }","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://tianqing.work/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://tianqing.work/tags/JAVA/"},{"name":"Servlet","slug":"Servlet","permalink":"http://tianqing.work/tags/Servlet/"}]},{"title":"常用的专业搜索工具（分类)","slug":"常用的专业搜索工具（分类","date":"2017-03-24T09:34:09.000Z","updated":"2017-03-24T11:16:24.691Z","comments":true,"path":"2017/03/24/常用的专业搜索工具（分类/","link":"","permalink":"http://tianqing.work/2017/03/24/常用的专业搜索工具（分类/","excerpt":"本文基于大家日常上网的需要，分类整理了不同检索需求的工具，主要包括：电子书、图片、网盘、音乐、工作机会以及商品价格检索。","text":"本文基于大家日常上网的需要，分类整理了不同检索需求的工具，主要包括：电子书、图片、网盘、音乐、工作机会以及商品价格检索。 一、电子书检索1、鸠摩搜书 鸠摩搜书是一款非常棒的电子书搜索引擎。有了它，你可以轻易发现其他站点上的电子书资源。这样可以省去很多时间。 2、BOOKZZ/Library Genesis 值得一提的是，这两个网站都可以不用翻墙，所以墙里的同学，也可以享受到来自世界的福利。 这两款可以说是英文教材资源站的神器了。 基本上，你想要的，它俩都能给你。 其他的电子书资源站点收录如下（含国内和国外）： 1、电子书网站汇总 注：这个是电子书资源汇总终极站，资源丰富的丧心病狂！ 二、图片检索1、多搜搜：www.duososo.com 2、原寸画像检索：gensun.org 3、incogna：www.incogna.com 4、百度识图 支持一下百度同学，毕竟国产 三、网盘资源检索：1、胖次搜索 胖次搜索是一个很有意思的网盘资源搜索引擎，可以解析被吞的百度云分享链接。 2、百度网盘搜索 百度网盘是比百度本身更靠谱的搜索工具。 其他的网盘搜索引擎收录如下： 1、盘搜：www.pansou.com 2、西林街：www.xilinjie.com 3、盘易搜：panyisou.com 4、麦库搜索：www.baidu10.net 5、云搜：www.daysou.com 6、找文件：www.zhaofile.com 7、360搜网盘www.360swp.com 8、尝鲜搜索：search.likebeta.com 9、吸盘：so.xpan.me/index.html 10、去转盘：www.quzhuanpan.com 四、音乐检索作为网易云的忠实拥簇，一般来说，刷刷评论区，随机听一听FM，再收一收网易的推荐，基本上我的音乐边界就可以触到了。 然而，对于那些视音乐为生命的乐迷来说，世界上的好音乐总是不嫌多的。 有什么办法可以找到更丰富的音乐资源，享受更极致的音乐体验呢？ 下面的音乐检索工具，相信你一定不会错过。 1、Listen 1 音乐播放器 Listen 1是一款搜索与播放来自网易云音乐，虾米，QQ音乐三个主流音乐网站的曲库软件。 这款软件的作用不言而喻，可以帮你减少在不同音乐站点搜索资源的时间花费。 软件本身支持windows、linux、MAC以及chrome和firefox的插件。 对多平台的支持，大大提高了普适性。 其他的音乐搜索工具收录如下： 1、Last.fm - 通过网上最大的音乐库收听免费音乐、观赏精彩视频 2、www.midomi.com 3、www.bored.com 4、www.sogua.com 五、职位搜索引擎按理说，职位搜索引擎是一个鸡肋般的存在。 因为国内的一些主流的招聘网站，基本上能够满足我们的需求。 智联、前程自不必说，拉勾、脉脉、boss直聘、猎聘、领英等，基本上就可以搞定我们的95%网络求职的需求。 一些垂着的，比如topys、站酷、秒聘，甚至水木社区招聘、itpub、豆瓣招聘小组等，都可以获得丰富的招聘机会。 因此机会从来不缺，但是我们缺一个获取机会的最快捷径。 这时候，一款合适的搜索引擎工具，就显得尤为重要了。 下面来分享几款较好的搜索引擎工具。 1、百度招聘 通过职位关键词，你可以找到大量的国内主流招聘网站发布的求职机会。 比如，前程、智联、拉勾、boss直聘等。 这样做的好处是明显的，不用疲于奔命，可以有效降低时间成本。 2、伯益 ：www.boryi.com 六、价格检索现在市场上的产品信息实在是太多太杂。 因为缺乏一个共同的标准，所以我们在购物的时候，总是满怀感叹：为什么同一件商品会有不同的价格。 这里面除了促销、进货成本的因素，平台本身也是一个很大的影响因子。 为了消除价格信息不对称引起的无效浪费， 我们需要一些有用的比价工具。 下面就是一些有效的比价网站。 1、比一比价 比一比价网是一款非常不错的购物价格搜索引擎。 主要检索各个购物网站同类商品的价格。比如京东、天猫、1号店、亚马逊、当当等。 网站主要支持关键词搜索，可以横向对比商品在各渠道的价格分布。 图书比价功能也很不错，堪比枣书。 2、历史价格检索 西贴真是一个神奇的网站。 作为一个商品历史价格查询器，西贴可以监控到某个商品的历史价格分布。 细心观察网站提供的价格变化曲线，我们可以发现一些不为察觉的价格猫腻。 若是放在双十一前后，大家是不是会忍住剁手的欲望？ 其他的价格检索收录如下： 1、Tangou：www.tangou.cn 2、寻购网：go.xungou.com 3、惠惠网 ：www.huihui.cn 写在最后： 适合自己的才是最好的！","categories":[{"name":"分享","slug":"分享","permalink":"http://tianqing.work/categories/分享/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://tianqing.work/tags/分享/"}]},{"title":"JAVA学习之JDBC","slug":"JAVA学习之JDBC","date":"2017-03-22T14:33:39.000Z","updated":"2017-07-13T08:58:14.784Z","comments":true,"path":"2017/03/22/JAVA学习之JDBC/","link":"","permalink":"http://tianqing.work/2017/03/22/JAVA学习之JDBC/","excerpt":"JDBC概述 JDBC:java database connectivity SUN公司提供的一套操作数据库的标准规范。 JDBC与数据库驱动的关系：接口与实现的关系。 JDBC规范（掌握四个核心对象）： DriverManager:用于注册驱动 Connection: 表示与数据库创建的连接 Statement: 操作数据库sql语句的对象 ResultSet: 结果集或一张虚拟表","text":"JDBC概述 JDBC:java database connectivity SUN公司提供的一套操作数据库的标准规范。 JDBC与数据库驱动的关系：接口与实现的关系。 JDBC规范（掌握四个核心对象）： DriverManager:用于注册驱动 Connection: 表示与数据库创建的连接 Statement: 操作数据库sql语句的对象 ResultSet: 结果集或一张虚拟表 开发一个JDBC程序（重要） 创建数据库表，并向表中添加测试数据 &lt;--创建数据库--&gt; create database mytest1; use mytest1; &lt;--创建数据库表--&gt; create table users( id int primary key auto_increment, name varchar(40), password varchar(40), email varchar(60), birthday date )character set utf8 collate utf8_general_ci; &lt;--添加数据--&gt; insert into users(name,password,email,birthday) values(&apos;zs&apos;,&apos;123456&apos;,&apos;zs@sina.com&apos;,&apos;1980-12-04&apos;); insert into users(name,password,email,birthday) values(&apos;lisi&apos;,&apos;123456&apos;,&apos;lisi@sina.com&apos;,&apos;1981-12-04&apos;); insert into users(name,password,email,birthday) values(&apos;wangwu&apos;,&apos;123456&apos;,&apos;wangwu@sina.com&apos;,&apos;1979-12-04&apos;); 创建java project项目，添加数据库驱动（*.jar） 实现JDBC操作 - 注册驱动 - 创建连接 - 得到执行sql语句的Statement对象 - 执行sql语句，并返回结果 - 处理结果 - 关闭资源 example: public class demo01 { public static void main(String[] args) throws Exception{ // TODO Auto-generated method stub //1、注册驱动 //DriverManager.registerDriver(new com.mysql.jdbc.Driver()); //1.加载驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2、创建连接 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mytest1&quot;, &quot;root&quot;, &quot;root&quot;); //3、得到执行sql语句的Statement对象 Statement stmt = conn.createStatement(); //4、执行sql语句，并返回结果 String sql = &quot;select id,name,password,email,birthday from users&quot;; ResultSet rs = stmt.executeQuery(sql); //5、处理结果 while (rs.next()) { System.out.println(rs.getObject(1)); System.out.println(rs.getObject(2)); System.out.println(rs.getObject(3)); System.out.println(rs.getObject(4)); System.out.println(rs.getObject(5)); } //6关闭资源 rs.close(); stmt.close(); conn.close(); } } JDBC常用的类和接口详解java.sql.Drivermanager类 : 创建连接 注册驱动 DriverManager.registerDriver(new com.mysql.jdbc.Driver());不建议使用原因有2个： 导致驱动被注册2次。 强烈依赖数据库的驱动jar 解决办法： 用Class.forName(&quot;com.mysql.jdbc.Driver&quot;);代替。 与数据库建立连接 static Connection getConnection(String url, String user, String password) getConnection(&quot;jdbc:mysql://localhost:3306/mytest1&quot;, &quot;root&quot;, &quot;root&quot;); URL:SUN公司与数据库厂商之间的一种协议。 jdbc:mysql://localhost:3306/day06 协议 子协议 IP:端口号 数据库 mysql: jdbc:mysql://localhost:3306/day14 或者 jdbc:mysql:///day14（默认本机连接） oracle: jdbc:oracle:thin:@localhost:1521:sid Properties info = new Properties();//要参考数据库文档 info.setProperty(&quot;user&quot;, &quot;root&quot;); info.setProperty(&quot;password&quot;,&quot;root&quot;); getConnection(String url, Properties info) getConnection(String url) DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/day14?user=root&amp;password=root&quot;); 实现一个用户登录的功能Demo:https://github.com/MuTouTQ/login","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://tianqing.work/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://tianqing.work/tags/JAVA/"},{"name":"JDBC","slug":"JDBC","permalink":"http://tianqing.work/tags/JDBC/"}]},{"title":"JAVA学习之JUnit","slug":"JAVA学习之JUnit","date":"2017-03-22T14:33:06.000Z","updated":"2017-03-23T06:04:28.078Z","comments":true,"path":"2017/03/22/JAVA学习之JUnit/","link":"","permalink":"http://tianqing.work/2017/03/22/JAVA学习之JUnit/","excerpt":"JUnit是什么？ JUnit是用于编写和运行可重复的自动化测试的开源测试框架， 这样可以保证我们的代码按预期工作。 JUnit可广泛用于工业和作为支架(从命令行)或IDE(如Eclipse)内单独的Java程序。","text":"JUnit是什么？ JUnit是用于编写和运行可重复的自动化测试的开源测试框架， 这样可以保证我们的代码按预期工作。 JUnit可广泛用于工业和作为支架(从命令行)或IDE(如Eclipse)内单独的Java程序。 JUnit提供 断言测试预期结果。 测试功能共享通用的测试数据。 测试套件轻松地组织和运行测试。 图形和文本测试运行。 JUnit用于测试 整个对象 对象的一部分 - 交互的方法或一些方法 几个对象之间的互动(交互) JUnit的特点 JUnit是用于编写和运行测试的开源框架。 提供了注释，以确定测试方法。 提供断言测试预期结果。 提供了测试运行的运行测试。 JUnit测试让您可以更快地编写代码，提高质量 JUnit是优雅简洁。它是不那么复杂以及不需要花费太多的时间。 JUnit测试可以自动运行，检查自己的结果，并提供即时反馈。没有必要通过测试结果报告来手动梳理。 JUnit测试可以组织成测试套件包含测试案例，甚至其他测试套件。 Junit显示测试进度的，如果测试是没有问题条形是绿色的，测试失败则会变成红色。 JUnit简单示例 使用工具：eclipse 测试类： Calculate.java public class Calculate { public int sum(int var1, int var2) { System.out.println(&quot;相加的值是: &quot; + var1 + &quot; + &quot; + var2); return var1 + var2; } } CalculateTest.java public class CalculateTest { Calculate calculation = new Calculate(); int sum = calculation.sum(2, 5); int testSum = 7; @Test public void testSum() { System.out.println(&quot;@Test sum(): &quot; + sum + &quot; = &quot; + testSum); assertEquals(sum, testSum); } } @Test的注解在 testSum()方法的上方。 这个注释指示该公共无效(public void)方法它所附着可以作为一个测试用例。因此，testSum()方法将用于测试公开方法 sum() 。 方法 assertEquals(sum, testsum)。assertEquals ([String message], object expected, object actual) 方法持有两个对象作为输入，并断言这两个对象相等。 如果要运行测试类，右键点击测试类，并选择 Run As -&gt; Junit Test。 JUnit注解在本节中，我们将提到支持在JUnit4基本注释，下表列出了这些注释的概括： 注解 描述@Testpublic void method() 测试注释指示该公共无效方法它所附着可以作为一个测试用例。@Beforepublic void method() Before注释表示，该方法必须在类中的每个测试之前执行，以便执行测试某些必要的先决条件。@BeforeClasspublic static void method()BeforeClass注释指出这是附着在静态方法必须执行一次并在类的所有测试之前。发生这种情况时一般是测试计算共享配置方法(如连接到数据库)。@Afterpublic void method()After 注释指示，该方法在执行每项测试后执行(如执行每一个测试后重置某些变量，删除临时变量等)@AfterClasspublic static void method()当需要执行所有的测试在JUnit测试用例类后执行，AfterClass注解可以使用以清理建立方法，(从数据库如断开连接)。注意：附有此批注(类似于BeforeClass)的方法必须定义为静态。@Ignorepublic static void method()当想暂时禁用特定的测试执行可以使用忽略注释。每个被注解为@Ignore的方法将不被执行。 让我们看看一个测试类，在上面提到的一些注解的一个例子。 AnnotationsTest.java package com.yiibai.junit; import static org.junit.Assert.*; import java.util.*; import org.junit.*; public class AnnotationsTest { private ArrayList testList; @BeforeClass public static void onceExecutedBeforeAll() { System.out.println(&quot;@BeforeClass: onceExecutedBeforeAll&quot;); } @Before public void executedBeforeEach() { testList = new ArrayList(); System.out.println(&quot;@Before: executedBeforeEach&quot;); } @AfterClass public static void onceExecutedAfterAll() { System.out.println(&quot;@AfterClass: onceExecutedAfterAll&quot;); } @After public void executedAfterEach() { testList.clear(); System.out.println(&quot;@After: executedAfterEach&quot;); } @Test public void EmptyCollection() { assertTrue(testList.isEmpty()); System.out.println(&quot;@Test: EmptyArrayList&quot;); } @Test public void OneItemCollection() { testList.add(&quot;oneItem&quot;); assertEquals(1, testList.size()); System.out.println(&quot;@Test: OneItemArrayList&quot;); } @Ignore public void executionIgnored() { System.out.println(&quot;@Ignore: This execution is ignored&quot;); } } 如果我们运行上面的测试，控制台输出将是以下几点： @BeforeClass: onceExecutedBeforeAll @Before: executedBeforeEach @Test: EmptyArrayList @After: executedAfterEach @Before: executedBeforeEach @Test: OneItemArrayList @After: executedAfterEach @AfterClass: onceExecutedAfterAll JUnit断言在本节中，我们将介绍一些断言方法。所有这些方法都受到 Assert 类扩展了java.lang.Object类并为它们提供编写测试，以便检测故障。下表中有一种最常用的断言方法的更详细的解释。 断言描述void assertEquals([String message], expected value, actual value)断言两个值相等。值可能是类型有 int, short, long, byte, char or java.lang.Object. 第一个参数是一个可选的字符串消息void assertTrue([String message], boolean condition)断言一个条件为真void assertFalse([String message],boolean condition)断言一个条件为假void assertNotNull([String message], java.lang.Object object)断言一个对象不为空(null)void assertNull([String message], java.lang.Object object)断言一个对象为空(null)void assertSame([String message], java.lang.Object expected, java.lang.Object actual)断言，两个对象引用相同的对象void assertNotSame([String message], java.lang.Object unexpected, java.lang.Object actual)断言，两个对象不是引用同一个对象void assertArrayEquals([String message], expectedArray, resultArray)断言预期数组和结果数组相等。数组的类型可能是 int, long, short, char, byte or java.lang.Object. 让我们看的一些前述断言的一个例子。 AssertionsTest.java package com.yiibai.junit; import static org.junit.Assert.*; import org.junit.Test; public class AssertionsTest { @Test public void test() { String obj1 = &quot;junit&quot;; String obj2 = &quot;junit&quot;; String obj3 = &quot;test&quot;; String obj4 = &quot;test&quot;; String obj5 = null; int var1 = 1; int var2 = 2; int[] arithmetic1 = { 1, 2, 3 }; int[] arithmetic2 = { 1, 2, 3 }; assertEquals(obj1, obj2); assertSame(obj3, obj4); assertNotSame(obj2, obj4); assertNotNull(obj1); assertNull(obj5); assertTrue(var1 var2); assertArrayEquals(arithmetic1, arithmetic2); } } 在以上类中我们可以看到，这些断言方法是可以工作的。 assertEquals() 如果比较的两个对象是相等的，此方法将正常返回；否则失败显示在JUnit的窗口测试将中止。 assertSame() 和 assertNotSame() 方法测试两个对象引用指向完全相同的对象。 assertNull() 和 assertNotNull() 方法测试一个变量是否为空或不为空(null)。 assertTrue() 和 assertFalse() 方法测试if条件或变量是true还是false。 assertArrayEquals() 将比较两个数组，如果它们相等，则该方法将继续进行不会发出错误。否则失败将显示在JUnit窗口和中止测试。 文章转载自：易百教程 [http:/www.yiibai.com]","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://tianqing.work/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://tianqing.work/tags/JAVA/"},{"name":"JUnit","slug":"JUnit","permalink":"http://tianqing.work/tags/JUnit/"}]},{"title":"JAVA学习之MySQL","slug":"JAVA学习之MySQL","date":"2017-03-21T13:52:33.000Z","updated":"2017-03-22T12:32:51.377Z","comments":true,"path":"2017/03/21/JAVA学习之MySQL/","link":"","permalink":"http://tianqing.work/2017/03/21/JAVA学习之MySQL/","excerpt":"本文主要记录MySQL数据库的简单使用。本部分记录了MySQL的安装、卸载，SQL语句的基础。 转载请注明：转载于Terry Tian的博客（www.mutouspace.cn）!","text":"本文主要记录MySQL数据库的简单使用。本部分记录了MySQL的安装、卸载，SQL语句的基础。 转载请注明：转载于Terry Tian的博客（www.mutouspace.cn）! 数据库概述数据库（DataBase，DB）：指长期保存在计算机的存储设备上，按照一定规则组织起来，可以被各种用户或应用共享的数据集合。(文件系统) 数据库管理系统（DataBase Management System，DBMS）：指一种操作和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制，以保证数据库的安全性和完整性。用户通过数据库管理系统访问数据库中的数据。 数据库软件应该为数据库管理系统，数据库是通过数据库管理系统创建和操作的。 数据库：存储、维护和管理数据的集合。 数据库的安装与配置安装与配置 卸载与修改密码卸载： 停止mysql服务 net stop mysql 启动mysql服务 net start mysql 卸载mysql 找到mysql 安装目录下的 my.ini datadir=”C:/ProgramData/MySQL/MySQL Server 5.5/Data/“ 修改密码 运行cmd 安装成功了打开cmd –&gt; mysql -uroot -p你的密码 修改mysql root用户密码 1) 停止mysql服务 运行输入services.msc 停止mysql服务 或者 cmd --&gt; net stop mysql 2) 在cmd下 输入 mysqld –skip-grant-tables 启动服务器 光标不动 （不要关闭该窗口） 3) 新打开cmd 输入mysql -u root -p 不需要密码 use mysql; update user set password=password(&apos;abc&apos;) WHERE User=&apos;root&apos;; 4) 关闭两个cmd窗口 在任务管理器结束mysqld 进程 5) 在服务管理页面 重启mysql 服务 密码修改完成 sql概述 SQL：Structure Query Language。（结构化查询语言） Sql的分类DDL（Data Definition Language）：数据定义语言，用来定义数据库对象：库、表、列等； CREATE、 ALTER、DROP DML（Data Manipulation Language）：数据操作语言，用来定义数据库记录（数据）； INSERT、 UPDATE、 DELETE DCL（Data Control Language）：数据控制语言，用来定义访问权限和安全级别； DQL（Data Query Language）：数据查询语言，用来查询记录（数据）。SELECT 注意：sql语句以;结尾 DDL:操作数据库、表、列等 使用的关键字：CREATE、 ALTER、 DROP example: CREATE TABLE emp ( id INT, NAME VARCHAR(50), gender VARCHAR(10), birthday DATE, entry_date DATE, job VARCHAR(100), salary DOUBLE, RESUME VARCHAR(200) ); -- 查看表的字段信息 DESC emp; -- 在emp TABLE中添加image列 ALTER TABLE emp ADD image BLOB; -- 修改job列，使其长度为60。 ALTER TABLE emp MODIFY job VARCHAR(60); -- 删除image列,一次只能删一列。 ALTER TABLE emp DROP image; -- 表名改为USER。 RENAME TABLE emp TO USER; -- 查看表格的创建细节 SHOW CREATE TABLE USER; -- 修改表的字符集为gbk ALTER TABLE USER CHARACTER SET gbk; -- 列名NAME修改为username ALTER TABLE USER CHANGE NAME username VARCHAR(100); DESC USER; -- 删除表 DROP TABLE USER ; DML操作(重要)插入操作：INSERT语法： INSERT INTO 表名（列名1，列名2 …）VALUES(列值1，列值2…);注意：列名与列值的类型、个数、顺序要一一对应。 可以把列名当做java中的形参，把列值当做实参。 值不要超出列定义的长度。 如果插入空值，请使用null 插入的日期和字符一样，都使用引号括起来。 练习 ： create table emp( id int, name varchar(100), gender varchar(10), birthday date, salary float(10,2), entry_date date, resume text ); INSERT INTO emp(id,name,gender,birthday,salary,entry_date,resume) VALUES(1,&apos;zhangsan&apos;,&apos;female&apos;,&apos;1990-5-10&apos;,10000,&apos;2015-5-5-&apos;,&apos;good girl&apos;); INSERT INTO emp(id,name,gender,birthday,salary,entry_date,resume) VALUES(2,&apos;lisi&apos;,&apos;male&apos;,&apos;1995-5-10&apos;,10000,&apos;2015-5-5&apos;,&apos;good boy&apos;); INSERT INTO emp(id,name,gender,birthday,salary,entry_date,resume) VALUES(3,&apos;wangwu&apos;,&apos;male&apos;,&apos;1995-5-10&apos;,10000,&apos;2015-5-5&apos;,&apos;good boy&apos;); -- 批量插入： INSERT INTO emp VALUES (4,&apos;zs&apos;,&apos;m&apos;,&apos;2015-09-01&apos;,10000,&apos;2015-09-01&apos;,NULL), (5,&apos;li&apos;,&apos;m&apos;,&apos;2015-09-01&apos;,10000,&apos;2015-09-01&apos;,NULL), (6,&apos;ww&apos;,&apos;m&apos;,&apos;2015-09-01&apos;,10000,&apos;2015-09-01&apos;,NULL); 修改操作 UPDATE语法：UPDATE 表名 SET 列名1=列值1，列名2=列值2 。。。 WHERE 列名=值 练习 ： -- 将所有员工薪水修改为5000元。 UPDATE emp SET salary=5000 -- 将姓名为’tom’的员工薪水修改为3000元。 UPDATE emp SET salary=3000 WHERE NAME=&apos;tom&apos;; -- 将姓名为’jerry’的员工薪水修改为4000元,gender改为female。 UPDATE emp SET salary=4000,gender=&apos;female&apos; WHERE NAME=&apos;jerry&apos;; -- 将蔡依林的薪水在原有基础上增加1000元。 UPDATE emp SET salary=salary+1000 WHERE NAME = &apos;蔡依林&apos;; 删除操作 DELETE语法 ： DELETE FROM 表名 【WHERE 列名=值】 练习 ： -- 删除表中名称为’zs’的记录。 DELETE FROM emp WHERE NAME=‘tom’; -- 删除表中所有记录。 DELETE FROM emp; -- 使用truncate删除表中记录。 TRUNCATE TABLE emp; DELETE 删除表中的数据，表结构还在;删除后的数据可以找回 TRUNCATE 删除是把表直接DROP掉，然后再创建一个同样的新表。 删除的数据不能找回。执行速度比DELETE快。 DQL操作 DQL数据查询语言 （重要）数据库执行DQL语句不会对数据进行改变，而是让数据库发送结果集给客户端。查询返回的结果集是一张虚拟表。 查询关键字：SELECT语法： SELECT 列名 FROM表名【WHERE –&gt; GROUP BY –&gt;HAVING–&gt; ORDER BY】 语法： SELECT selection_list /*要查询的列名称*/ FROM table_list /*要查询的表名称*/ WHERE condition /*行条件*/ GROUP BY grouping_columns /*对结果分组*/ HAVING condition /*分组后的行条件*/ ORDER BY sorting_columns /*对结果分组*/ LIMIT offset_start, row_count /*结果限定*/ 开始之前让我们先建几个表并插入数据 CREATE TABLE stu ( sid CHAR(6), sname VARCHAR(50), age INT, gender VARCHAR(50) ); INSERT INTO stu VALUES(&apos;S_1001&apos;, &apos;liuYi&apos;, 35, &apos;male&apos;); INSERT INTO stu VALUES(&apos;S_1002&apos;, &apos;chenEr&apos;, 15, &apos;female&apos;); INSERT INTO stu VALUES(&apos;S_1003&apos;, &apos;zhangSan&apos;, 95, &apos;male&apos;); INSERT INTO stu VALUES(&apos;S_1004&apos;, &apos;liSi&apos;, 65, &apos;female&apos;); INSERT INTO stu VALUES(&apos;S_1005&apos;, &apos;wangWu&apos;, 55, &apos;male&apos;); INSERT INTO stu VALUES(&apos;S_1006&apos;, &apos;zhaoLiu&apos;, 75, &apos;female&apos;); INSERT INTO stu VALUES(&apos;S_1007&apos;, &apos;sunQi&apos;, 25, &apos;male&apos;); INSERT INTO stu VALUES(&apos;S_1008&apos;, &apos;zhouBa&apos;, 45, &apos;female&apos;); INSERT INTO stu VALUES(&apos;S_1009&apos;, &apos;wuJiu&apos;, 85, &apos;male&apos;); INSERT INTO stu VALUES(&apos;S_1010&apos;, &apos;zhengShi&apos;, 5, &apos;female&apos;); INSERT INTO stu VALUES(&apos;S_1011&apos;, &apos;xxx&apos;, NULL, NULL); CREATE TABLE emp( empno INT, ename VARCHAR(50), job VARCHAR(50), mgr INT, hiredate DATE, sal DECIMAL(7,2), comm DECIMAL(7,2), deptno INT ) ; INSERT INTO emp VALUES(7369,&apos;SMITH&apos;,&apos;CLERK&apos;,7902,&apos;1980-12-17&apos;,800,NULL,20); INSERT INTO emp VALUES(7499,&apos;ALLEN&apos;,&apos;SALESMAN&apos;,7698,&apos;1981-02-20&apos;,1600,300,30); INSERT INTO emp VALUES(7521,&apos;WARD&apos;,&apos;SALESMAN&apos;,7698,&apos;1981-02-22&apos;,1250,500,30); INSERT INTO emp VALUES(7566,&apos;JONES&apos;,&apos;MANAGER&apos;,7839,&apos;1981-04-02&apos;,2975,NULL,20); INSERT INTO emp VALUES(7654,&apos;MARTIN&apos;,&apos;SALESMAN&apos;,7698,&apos;1981-09-28&apos;,1250,1400,30); INSERT INTO emp VALUES(7698,&apos;BLAKE&apos;,&apos;MANAGER&apos;,7839,&apos;1981-05-01&apos;,2850,NULL,30); INSERT INTO emp VALUES(7782,&apos;CLARK&apos;,&apos;MANAGER&apos;,7839,&apos;1981-06-09&apos;,2450,NULL,10); INSERT INTO emp VALUES(7788,&apos;SCOTT&apos;,&apos;ANALYST&apos;,7566,&apos;1987-04-19&apos;,3000,NULL,20); INSERT INTO emp VALUES(7839,&apos;KING&apos;,&apos;PRESIDENT&apos;,NULL,&apos;1981-11-17&apos;,5000,NULL,10); INSERT INTO emp VALUES(7844,&apos;TURNER&apos;,&apos;SALESMAN&apos;,7698,&apos;1981-09-08&apos;,1500,0,30); INSERT INTO emp VALUES(7876,&apos;ADAMS&apos;,&apos;CLERK&apos;,7788,&apos;1987-05-23&apos;,1100,NULL,20); INSERT INTO emp VALUES(7900,&apos;JAMES&apos;,&apos;CLERK&apos;,7698,&apos;1981-12-03&apos;,950,NULL,30); INSERT INTO emp VALUES(7902,&apos;FORD&apos;,&apos;ANALYST&apos;,7566,&apos;1981-12-03&apos;,3000,NULL,20); INSERT INTO emp VALUES(7934,&apos;MILLER&apos;,&apos;CLERK&apos;,7782,&apos;1982-01-23&apos;,1300,NULL,10); CREATE TABLE dept( deptno INT, dname VARCHAR(14), loc VARCHAR(13) ); INSERT INTO dept VALUES(10, &apos;ACCOUNTING&apos;, &apos;NEW YORK&apos;); INSERT INTO dept VALUES(20, &apos;RESEARCH&apos;, &apos;DALLAS&apos;); INSERT INTO dept VALUES(30, &apos;SALES&apos;, &apos;CHICAGO&apos;); INSERT INTO dept VALUES(40, &apos;OPERATIONS&apos;, &apos;BOSTON&apos;); 基础查询1.1 查询所有列 SELECT * FROM stu; 1.2 查询指定列 SELECT sid, sname, age FROM stu; 条件查询-- 查询性别为女，并且年龄&gt;=50的记录 SELECT * FROM stu WHERE gender=&apos;female&apos; AND age &gt;=50; -- 查询学号为S_1001，或者姓名为liSi的记录 SELECT * FROM stu WHERE sid =&apos;S_1001&apos; OR sname=&apos;liSi&apos;; -- 查询学号为S_1001，S_1002，S_1003的记录 SELECT * FROM stu WHERE sid IN (&apos;S_1001&apos;,&apos;S_1002&apos;,&apos;S_1003&apos;); -- 查询学号不是S_1001，S_1002，S_1003的记录 SELECT * FROM stu WHERE sid NOT IN (&apos;S_1001&apos;,&apos;S_1002&apos;,&apos;S_1003&apos;); -- 查询年龄为null的记录 SELECT * FROM stu WHERE age IS NULL; -- 查询年龄在20到40之间的学生记录 SELECT * FROM stu WHERE age&gt;=20 AND age&lt;=40; -- 或者 SELECT * FROM stu WHERE age BETWEEN 20 AND 40; -- 查询性别非男的学生记录 SELECT * FROM stu WHERE gender!=&apos;male&apos;; -- 或者 SELECT * FROM stu WHERE gender&lt;&gt;&apos;male&apos;; -- 或者 SELECT * FROM stu WHERE NOT gender=&apos;male&apos;; -- 查询姓名不为null的学生记录 SELECT * FROM stu WHERE sname IS NOT NULL; 模糊查询 当想查询姓名中包含a字母的学生时就需要使用模糊查询了。模糊查询需要使用关键字LIKE。 通配符: _ ：任意一个字符 % ：任意0~n个字符 Example: -- 查询姓名由5个字母构成的学生记录 SELECT * FROM stu WHERE sname LIKE &apos;_____&apos;; -- 模糊查询必须使用LIKE关键字。其中 “_”匹配任意一个字母，5个“_”表示5个任意字母。 -- 3.2 查询姓名由5个字母构成，并且第5个字母为“i”的学生记录 SELECT * FROM stu WHERE sname LIKE &apos;____i&apos;; -- 3.3 查询姓名以“z”开头的学生记录 SELECT * FROM stu WHERE sname LIKE &apos;z%&apos;; -- 其中“%”匹配0~n个任何字母。 -- 3.4 查询姓名中第2个字母为“i”的学生记录 SELECT * FROM stu WHERE sname LIKE &apos;_i%&apos;; -- 3.5 查询姓名中包含“a”字母的学生记录 SELECT * FROM stu WHERE sname LIKE &apos;%a%&apos;; 字段控制查询SELECT * FROM emp; -- 去除重复记录 SELECT DISTINCT deptno,mgr FROM emp; -- 查看雇员的月薪与佣金之和 SELECT * ,sal+comm FROM emp; -- 过滤null 并起别名 SELECT * ,sal+IFNULL(comm,0) AS total FROM emp; 排序 order by 列名 asc(默认) desc -- 查询所有学生记录，按年龄升序排序 SELECT * FROM stu ORDER BY age ASC; -- 查询所有学生记录，按年龄降序排序 SELECT * FROM stu ORDER BY age DESC; -- 查询所有雇员，按月薪降序排序，如果月薪相同时，按编号升序排序 SELECT * FROM emp ORDER BY sal DESC,empno ASC; 聚合函数 聚合函数是用来做纵向运算的函数： COUNT()：统计指定列不为NULL的记录行数； MAX()：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算； MIN()：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算； SUM()：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0； AVG()：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0； -- 查询emp表中记录数： SELECT COUNT(*) AS cnt FROM emp; -- 查询emp表中有佣金的人数： SELECT COUNT(comm) cnt FROM emp; -- 注意，因为count()函数中给出的是comm列，那么只统计comm列非NULL的行数。 -- 查询emp表中月薪大于2500的人数： SELECT COUNT(*) FROM emp WHERE sal &gt; 2500; -- 统计月薪与佣金之和大于2500元的人数： SELECT COUNT(*) AS cnt FROM emp WHERE sal+IFNULL(comm,0) &gt; 2500; -- 查询有佣金的人数，有领导的人数： SELECT COUNT(comm), COUNT(mgr) FROM emp; -- 查询所有雇员月薪和： SELECT SUM(sal) FROM emp; -- 查询所有雇员月薪和，以及所有雇员佣金和： SELECT SUM(sal), SUM(comm) FROM emp; -- 查询所有雇员月薪+佣金和： SELECT SUM(sal+IFNULL(comm,0)) FROM emp; -- 统计所有员工平均工资： SELECT AVG(sal) FROM emp; -- MAX和MIN -- 查询最高工资和最低工资： SELECT MAX(sal), MIN(sal) FROM emp; 分组查询 注：凡和聚合函数同时出现的列名，一定要写在group by 之后 -- 查询每个部门的部门编号和每个部门的工资和： SELECT deptno, SUM(sal) FROM emp GROUP BY deptno; -- 查询每个部门的部门编号以及每个部门的人数： SELECT deptno,COUNT(*) FROM emp GROUP BY deptno; -- 查询每个部门的部门编号以及每个部门工资大于1500的人数： SELECT deptno,COUNT(*) FROM emp WHERE sal&gt;1500 GROUP BY deptno; -- 查询工资总和大于9000的部门编号以及工资和： SELECT deptno, SUM(sal) FROM emp GROUP BY deptno HAVING SUM(sal) &gt; 9000; 注： having与where的区别: 1.having是在分组后对数据进行过滤. where是在分组前对数据进行过滤 2.having后面可以使用聚合函数(统计函数) where后面不可以使用聚合函数。 WHERE是对分组前记录的条件，如果某行记录没有满足WHERE子句的条件，那么这行记录不会参加分组；而HAVING是对分组后数据的约束。 LIMIT LIMIT用来限定查询结果的起始行，以及总行数。 -- 查询5行记录，起始行从0开始 SELECT * FROM emp LIMIT 0, 5; -- 查询10行记录，起始行从3开始 SELECT * FROM emp LIMIT 3, 10;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://tianqing.work/categories/数据库/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://tianqing.work/tags/JAVA/"},{"name":"MySQL","slug":"MySQL","permalink":"http://tianqing.work/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"http://tianqing.work/tags/数据库/"}]},{"title":"使用Hexo+github建设个人博客教程","slug":"使用Hexo-github建设个人博客教程","date":"2017-02-18T07:46:58.000Z","updated":"2020-08-18T15:11:06.565Z","comments":true,"path":"2017/02/18/使用Hexo-github建设个人博客教程/","link":"","permalink":"http://tianqing.work/2017/02/18/使用Hexo-github建设个人博客教程/","excerpt":"前言本片文章主要用来记录搭建Hexo静态博客的过程，用于以后搭建博客更加方便。 主要内容： 列出博客搭建环境+所需工具； 环境的配置与工具的安装简述，以及简单的使用教程，安装Git、Node.js环境以及Hexo框架； 创建Hexo项目，并本地运行查看效果 修改项目配置文件（根目录下的_config.yml文件） 安装Hexo框架主题（推荐：Next或yelee主题，本人用的yelee），对主题进行配置，主要是修改theme目录下的_config.yml文件 将本地设置好的Hexo项目发布到Github Pages上（包括绑定自己的域名）（这里会介绍如何写文章） 总结","text":"前言本片文章主要用来记录搭建Hexo静态博客的过程，用于以后搭建博客更加方便。 主要内容： 列出博客搭建环境+所需工具； 环境的配置与工具的安装简述，以及简单的使用教程，安装Git、Node.js环境以及Hexo框架； 创建Hexo项目，并本地运行查看效果 修改项目配置文件（根目录下的_config.yml文件） 安装Hexo框架主题（推荐：Next或yelee主题，本人用的yelee），对主题进行配置，主要是修改theme目录下的_config.yml文件 将本地设置好的Hexo项目发布到Github Pages上（包括绑定自己的域名）（这里会介绍如何写文章） 总结 准备工作在搭建博客时，你需要做以下准备： 确定自己的系统为Windows;(因为博主用的系统是Windows10，为了避免浪费您的时间，如果不是Windows系统就不要看了。) Git下载，node.js下载。 本文所使用的环境： Windows 10 Git version 2.11.1.windows.1 node.js v6.9.5 LTS hexo 开始搭建博客Git下载安装及简单实用为什么要在电脑上安装Git呢？我相信大多计算机专业的同学对Git的应该不陌生了，Git可以说是现如今最好用的、最先进的分布式版本控制系统（没有之一）。Git在接下来的环境部署及部署博客到github Pages时都是需要的。大家如果有兴趣可以阅读我的博客（Git的简单使用），对Git进行简单的了解。如果了解Git也没有关系，只要你按照教程一步一步来也可以。 下载Git 我们可以在Git的官网下载我们所需要的git，我选择的是最新版的Git Windows X64 版本。 安装Git Git的安装也很简单，就像安装我们平时所需要的软件一样，教程参考：Git的安装。 Git的简单实用 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 第一步，使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit，完成。 我们在这里不太需要git的命令操作，一般只需要git的的shell窗口进行一些操作。 node.js的下载安装下载 打开 Nodejs 下载页面，选择合适你当前系统版本的安装包（建议使用 LTS 版本的）。 安装 双击安装文件 -&gt; 下一步 -&gt; 下一步… 【具体操作请参考网上的一篇文章：Node.js安装及环境配置之Windows篇】 Hexo框架的安装首先我们可以看一下hexo的官网，了解一下hexo。 Windows中的安装 打开命令行 Win+R或者点击开始按钮–&gt;运行–&gt;输入“cmd”; 用 Git Bash 输入命令 npm install hexo-cli -g 输入完命令后就开始了hexo的安装，这里可能需要等待一段时间，时间不确定，只要不报错就可以了。 创建Hexo本地博客 接下来我们在一个本地盘自定义路径中创建一个文件夹作为我的项目文件，我在这里选择了在G盘下新建了一个名为TerryBlog的文件夹，作为我的项目文件，路径为【G:\\TerryBlog】.在G盘下，点击鼠标右键–&gt;Git Bash，打开命令输入框。输入命令如下： hexo init TerryBlog //hexo init +你的项目名称，如我的为TerryBlog 执行完上述命令后，我们就创建了TerryBlog文件夹，进入刚创建的TerryBlog项目目录，命令操作如下： cd TerryBlog //进入TerryBlog目录 或者直接在TerryBlog文件夹下，再点击鼠标右键–&gt;Git Bash，打开命令输入框。再输入以下命令： npm install 安装完成之后，【G:\\TerryBlog】目录结构是这样的： 到此为止，一个博客就已经搭建好了，现在我们启动 hexo 本地服务，看下默认的博客是怎样的，命令如下： hexo s 在浏览器中输入：http://localhost:4000/进行访问 ** 如果要停止 hexo 服务：在 Git Bash 下按 Ctrl + C即可** 到这里我们简单的hexo博客基本就完成一部分了！是不是很开心，如果不进行主题美化的话，我们马上就可以有一个自己的博客了。 修改项目配置文件 在这里我们修改的是【G:\\TerryBlog】路径下的 _config.yml 站点主题配置文件，我的配置如下： 注意：修改之前最好备份一下。 # Hexo Configuration ## Docs: https://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site 这一块区域主要是设置博客的主要说明，需要注意的是：每个冒号后面都是有一个空格，然后再书写自己的内容的 title: Terry_Tian Code #网站标题 subtitle: 行是知之始 知是行之成 #网站副标题 description: 在山的这边，海的那边，有一只程序猿。。。 #描述 author: Terry Tian #博主名字 avatar: http://olg3gwtbm.bkt.clouddn.com/head.jpg #博主头像 email: 1015236187@qq.com #邮箱 language: zh-Hans #语言 timezone: #网站时区。Hexo默认使用电脑时区 # URL,这一块一般可以设置的是 url 这个参数，比如我要设置绑定域名的，这里就需要填写我的域名信息 ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: http://mutouspace.cn/ root: / permalink: :year/:month/:day/:title/ permalink_defaults: # Directory source_dir: source public_dir: public tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code i18n_dir: :lang skip_render: # Writing new_post_name: :title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: enable: true line_number: true auto_detect: false tab_replace: # Category &amp; Tag default_category: uncategorized category_map: tag_map: # Date / Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination ## Set per_page to 0 to disable pagination per_page: 10 pagination_dir: page # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: yelee # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: git@github.com:MuTouTQ/MuTouTQ.github.io.git branch: master search: path: search.xml field: post 做完这一些之后再在Git Bash 命令框中，输入 hexo s 重新启动服务，在浏览器中输入：http://localhost:4000/进行访问,查看一下效果。 安装Hexo框架主题 在上一步完成后，你会发现虽然改了一部分配置，但页面还是很吃藕，接下来，咱们就要给咱们的博客美美容了。hexo的主题有很多，大家可以去这里选一下，hexo-theme：https://hexo.io/themes/. 我选择的是yelee主题：yelee 还是让 Git Bash 保持在【G:\\TerryBlog】目录下，然后输入命令： git clone https://github.com/MOxFIVE/hexo-theme-yelee.git themes/yelee 这样就在 【G:\\TerryBlog\\themes】目录下生成了一个 yelee 文件夹，里面有我们刚刚 clone 下来的主题内容。 我们现在要修改【G:\\TerryBlog】目录下的项目配置文件：_config.yml，把对应的主题目录名改下，主要是将配置中的 theme: yelee修改。 注意：该配置文件中的键值之间一定要有空格，否则轻则没有作用，重则报错，无法启动。 更改主题目录名后，我们还要重新生成主题静态内容，继续在 Git Bash 中输入命令输入如下命令： hexo g //重新生成静态博客的所有内容 hexo s //重启 hexo 本地服务 重新访问：http://localhost:4000/，看一下效果. 修改Hexo框架主题 上一步完成后，看到的是yelee的默认主题，这里我们可以再次配置一下，修改的是【G:\\TerryBlog\\themes\\yelee】路径下的 _config.yml文件。这里我们可以跟着Yelee 主题使用说明来修改。 发布到Github Pages上创建Github Pages并SSH授权 现在假设你已经有一个 Gtihub 账号，你还需要一个特别的仓库，特别在仓库名就是你的 Github 账号登录名，比如我的用户名是：tiantsing，那我要创建的仓库名字完整滴填写是：tiantsing.github.io ; 仔细的人可能看到，你的仓库名根本不和你的用户名一样，由于我之前已经创建了一个这样特别的仓库，再创建一个就会提示错误，为了演示方便，所以删了一个T。 创建好仓库之后，要本地生成 SSH 秘钥，方便电脑上的 git 软件好提交内容到 Github 上。 【具体可以参考网上的一篇文章：Git安装及SSH Key管理之Windows篇】 现在用记事本打开公钥，复制文件中的所有内容。访问：https://github.com/settings/ssh， Title：自己随便取 Key：把刚刚复制的都粘贴进来 把本地的博客内容同步到 Github 上 要把本地的静态博客同步到 Github，我们还需要先安装两个跟部署相关的 hexo 插件： cd G:\\TerryBlog //进入TerryBlog项目目录 上一步，我们可以到 G:\\TerryBlog 路径下 Git Bash 一下； npm/cnpm install hexo-server --save //创建 npm/cnpm install hexo-deployer-git --save //安装自动部署发布工具 编辑TerryBlog的项目配置文件：_config.yml 官网对此配置的介绍：https://hexo.io/zh-cn/docs/configuration.html 主要改这里（一般在最后面）： # Deployment ## 这里是重点，这里是修改发布地址，因为我们前面已经加了 SSH 密钥信息在 Github 设置里面了，所以只要我们电脑里面持有那两个密钥文件就可以无需密码地跟 Github 做同步。 ## 需要注意的是这里的 repo 采用的是 ssh 的地址，而不是 https 的。分支我们默认采用 master 分支，以后你翅膀硬了要换其他也无所谓。 ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: git@github.com:MuTouTQ/MuTouTQ.github.io.git branch: master 编辑完项目配置文件后我们需要重新部署： cd G:\\TerryBlog //进入TerryBlog项目目录 上一步，我们可以到 G:\\TerryBlog 路径下 Git Bash 一下； hexo clean//先清除掉已经生成的旧文件 hexo g //再生成一次静态文件 hexo s //在本地预览下 hexo d //本地没问题之后，Ctrl + C 停掉本地预览，使用部署命令部署到 Github 上 访问服务器地址进行检查：http://MuTouTQ.github.io/，该访问地址是之前在github上的创建的仓库名称，输入你的github用户名 + .github.io 绑定域名 创建CNAME文件 我们要一个 CNAME 文件（文件名叫 CNAME，文件没有后缀，里面的内容为你购买的域名，不要以http以及www等前缀，只需域名本身即可，如：mutouspace.cn。这个CNAME可以你先建一个txt文件，把后缀名去掉），把该文件放在 G:\\TerryBlog 目录下。 获取Github的ip地址 实际获取的是你github上博客项目的ip（即：tiantsing.github.io），打开命令窗口，输入【ping tiantsing.github.io】来查看ip地址，并记录下来; 添加DNS Service记录 我的域名是腾讯云上买的，用的腾讯云的域名解析，将ip地址和你买的域名绑定就好了，域名解析后需要等待几分钟才能被访问; 到此为止，我们的博客就成功配置完了！ 发表一篇文章 在G:\\TerryBlog 路径下Git Bash执行命令： hexo new &quot;my new post&quot; 在G:\\TerryBlog\\source_post中打开my-new-post.md，打开方式使用记事本或notepad++（推荐使用Markdown编辑软件）。 hexo中写文章使用的是Markdown，没接触过的可以看下Markdown语法说明. title: my new post #可以改成中文的，如“新文章” date: 2015-04-08 22:56:29 #发表日期，一般不改动 categories: blog #文章文类 tags: [博客，文章] #文章标签，多于一项时用这种格式，只有一项时使用tags: blog #这里是正文，用markdown写，你可以选择写一段显示在首页的简介后，加上 #在之前的内容会显示在首页，之后的内容会被隐藏，当游客点击Read more才能看到。 写完文章后，你可以使用1. hexo g生成静态文件。2. hexo s在本地预览效果。3.hexo d同步到github，然后使用tianqing.work进行访问。 HEXO插入图片第一步：安装插件，在 hexo 根目录打开 Git Bash ,执行npm install hexo-asset-image --save第二步：打开 hexo 的配置文件_config.yml找到 post_asset_folder，把这个选项从false改成true第三步：打开/node_modules/hexo-asset-image/index.js将内容更换为下面的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&apos;use strict&apos;;var cheerio = require(&apos;cheerio&apos;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split(&apos;.&apos;);hexo.extend.filter.register(&apos;after_post_render&apos;, function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, &apos;/&apos;, 1) + 1; else var beginPos = getPosition(link, &apos;/&apos;, 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf(&apos;/&apos;) + 1; link = link.substring(beginPos, endPos); var toprocess = [&apos;excerpt&apos;, &apos;more&apos;, &apos;content&apos;]; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $(&apos;img&apos;).each(function()&#123; if ($(this).attr(&apos;src&apos;))&#123; // For windows style path, we replace &apos;\\&apos; to &apos;/&apos;. var src = $(this).attr(&apos;src&apos;).replace(&apos;\\\\&apos;, &apos;/&apos;); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&apos;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&apos;/&apos;).filter(function(elem)&#123; return elem != &apos;&apos;; &#125;); var srcArray = src.split(&apos;/&apos;).filter(function(elem)&#123; return elem != &apos;&apos; &amp;&amp; elem != &apos;.&apos;; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&apos;/&apos;); $(this).attr(&apos;src&apos;, config.root + link + src); console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 第四步：现在就可以插入图片了，比如 hexo new post test 之后就在source/_posts生成teest.md文件和test文件夹，我们把要插入的图片复制到test文件夹内，在test.md文件里面按markdown的标准写,（我的文件名是test.jpeg）比如 总结常用hexo命令常见命令 hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo new post &quot;pageName&quot; #新建文章与文件夹 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 缩写： hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 组合命令： hexo s -g #生成并本地预览 hexo d -g #生成并上传 最终效果 可以访问我的git博客来查看效果： https://tiantsing.github.io/ 参考 基于Hexo+Github Pages的博客搭建 使用Hexo搭建个人博客(基于hexo3.0) 使用hexo+github搭建免费个人博客详细教程","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://tianqing.work/categories/Hexo/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://tianqing.work/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"http://tianqing.work/tags/Hexo/"},{"name":"node","slug":"node","permalink":"http://tianqing.work/tags/node/"},{"name":"github","slug":"github","permalink":"http://tianqing.work/tags/github/"}]},{"title":"测试二","slug":"DEMO1","date":"2017-02-17T11:51:30.000Z","updated":"2017-02-17T13:18:19.297Z","comments":true,"path":"2017/02/17/DEMO1/","link":"","permalink":"http://tianqing.work/2017/02/17/DEMO1/","excerpt":"","text":"","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"http://tianqing.work/tags/测试/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-02-17T11:51:30.000Z","updated":"2017-03-06T14:14:31.511Z","comments":true,"path":"2017/02/17/hello-world/","link":"","permalink":"http://tianqing.work/2017/02/17/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://tianqing.work/tags/Hexo/"}]}]}